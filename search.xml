<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9——BIOS和DOS功能调用</title>
      <link href="2021/01/07/9-bios-he-dos-gong-neng-diao-yong/"/>
      <url>2021/01/07/9-bios-he-dos-gong-neng-diao-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="第九讲-BIOS-和-DOS-功能调用"><a href="#第九讲-BIOS-和-DOS-功能调用" class="headerlink" title="第九讲 BIOS 和 DOS 功能调用"></a>第九讲 BIOS 和 DOS 功能调用</h1><h2 id="一-BIOS-和-DOS-简介"><a href="#一-BIOS-和-DOS-简介" class="headerlink" title="一 BIOS 和 DOS 简介"></a>一 BIOS 和 DOS 简介</h2><p>BIOS/DOS 的每一个功能对应着一个中断服务程序，BIOS/DOS 中断属于软件中断，其中 5-1FH 号中断为 BIOS 中断，20H-3FH 号中断为 DOS 中断，剩余 40-FFH 号中断为自由中断。</p><p>IBM PC 机在只读存储器 ROM 中固化的一组软件，形成 PC 机基本输入输出系统，称为 ROM BIOS，其包括以下功能：</p><ul><li>系统自检及初始化</li><li>系统服务</li><li>硬件中断处理</li></ul><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107152643992.png" alt="CPU中断、8259A中断、BIOS中断"></p><p>磁盘操作系统（Disk Operation System）是早起 PC 机重要操作系统之一，主要包括三个模块：</p><ul><li>IBMBIO.COM：DOS 与 ROM BIOS 的接口</li><li>IBMDOS.COM：在 IBMBIO.COM 基础上的文件管理程序和处理程序</li><li>COMMAND.COM：DOS 的命令处理程序</li></ul><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107152558120.png" alt="DOS功能"></p><h2 id="二-键盘-I-O"><a href="#二-键盘-I-O" class="headerlink" title="二 键盘 I/O"></a>二 键盘 I/O</h2><h3 id="1、字符码与扫描码"><a href="#1、字符码与扫描码" class="headerlink" title="1、字符码与扫描码"></a>1、字符码与扫描码</h3><p>键盘可以得到按键的位置，并以位置为扫描码，通过8位数据线送往主机。当 “按下” 或 “松开” 一个键时，若允许中断，会产生一个 9 号中断。该中断会从 8259A 芯片中读取一个扫描码，低7位为扫描码，最高位 0/1 表示按下或断开。随后生成 ASCII 码，或指定操作。转换得到的字符码和扫描码存储于 BIOS 数据区的键盘缓冲区中。随后可以使用 BIOS 16H 号功能或 DOS 21H 号从队列中取出字符码和扫描码进行处理。</p><h3 id="2、BIOS-键盘中断（16H）"><a href="#2、BIOS-键盘中断（16H）" class="headerlink" title="2、BIOS 键盘中断（16H）"></a>2、BIOS 键盘中断（16H）</h3><div class="table-container"><table><thead><tr><th>中断号</th><th>寄存器参数</th><th>功能</th></tr></thead><tbody><tr><td>16H</td><td>AH=0</td><td>从键盘读字符<br>AL=字符码，AH=扫描码</td></tr><tr><td>16H</td><td>AH=1</td><td>从<u>键盘缓冲区</u>读字符<br>ZF=0，AL=字符码，AH=扫描码<br>ZF=1，表示缓冲区为空</td></tr><tr><td>16H</td><td>AH=2</td><td>AL=键盘状态字节</td></tr></tbody></table></div><p>当按下控制键、双态键或特殊请求键时，其扫描码不会加入缓冲区中，而是通过键盘状态字节进行记录</p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107154331600.png" alt="键盘状态字节" style="zoom: 50%;"></p><h3 id="3、DOS-键盘功能调用（21H）"><a href="#3、DOS-键盘功能调用（21H）" class="headerlink" title="3、DOS 键盘功能调用（21H）"></a>3、DOS 键盘功能调用（21H）</h3><div class="table-container"><table><thead><tr><th>AH</th><th>功能</th><th>调用参数</th><th>返回参数</th></tr></thead><tbody><tr><td>1</td><td>从键盘中输入一个字符并显示在屏幕上</td><td></td><td>AL=字符码</td></tr><tr><td>6</td><td>从键盘缓冲区中读取键盘字符码</td><td>DL=0FFH</td><td>若有字符可取，AL=字符码，ZF=0<br>否则AL=0，ZF=1</td></tr><tr><td>7</td><td>从键盘中输入一个字符并不显示</td><td></td><td>AL=字符码</td></tr><tr><td>8</td><td>从键盘中输入一个字符并不显示，检测 ctrl+break</td><td></td><td>AL=字符码</td></tr><tr><td>A</td><td>读取一串字符到缓冲区</td><td>DS:DX=缓冲区首地址</td><td></td></tr><tr><td>B</td><td>读取键盘状态</td><td></td><td>若有键入，AL=0FFH<br>否则AL=0</td></tr><tr><td>C</td><td>清除键盘缓冲区并调用一种键盘功能</td><td>AL=键盘功能号</td><td>依键盘功能号而定</td></tr></tbody></table></div><p>注，输入字符串的缓冲区定义方式</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">datas segmentsmax db 21; 缓冲区首址，存储最大字符数（包括回车）sact db ?; 存储实际输入字符数stri db 21 dup (?); 存储真正输入的字符datas ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三-显示器-I-O"><a href="#三-显示器-I-O" class="headerlink" title="三 显示器 I/O"></a>三 显示器 I/O</h3><h3 id="1、字符属性"><a href="#1、字符属性" class="headerlink" title="1、字符属性"></a>1、字符属性</h3><p>文本显示模式下，屏幕被划分为 25$\times$80，左上角坐标为（0,0），右下角坐标为（24,79）。字符以矩形块在屏幕上显示，主要显示字符集大小有 $8\times8$、$8\times14$、$8\times16$。</p><p>屏幕上每个位置对应于主存中的一段空间，存储器中一个字（高字节属性、低字节字符码）表示屏幕中对应位置的一个字符。单色显示适配器 MDA 显存起始地址为 B000:0000，CGA、VGA、EGA 显存起始地址为 B800:0000。对于 VGA，其 0，1,2,3 页的起始地址分别为 B800:0000,B800:1000,B800:2000,B800:3000。</p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107171859140.png" alt="字符属性"></p><h3 id="2、BIOS-显示中断调用（10H）"><a href="#2、BIOS-显示中断调用（10H）" class="headerlink" title="2、BIOS 显示中断调用（10H）"></a>2、BIOS 显示中断调用（10H）</h3><div class="table-container"><table><thead><tr><th>AH</th><th>功能</th><th>调用参数</th><th>返回参数</th></tr></thead><tbody><tr><td>1</td><td>设置光标类型</td><td>CH=光标开始行<br>CL=光标结束行</td><td>无</td></tr><tr><td>2</td><td>设置光标位置</td><td>BH=页号，DH=行号，DL=列号</td><td>无</td></tr><tr><td>3</td><td>读出当前光标位置</td><td>BH=页号</td><td>DH=行号<br>DL=列号<br>CX=光标大小</td></tr><tr><td>6</td><td>初始窗口或窗口上滚</td><td>AL=上滚行数<br>CX=左上角行、列号<br>DX=右下角行、列号<br>BH=空白行的属性</td><td>无</td></tr><tr><td>7</td><td>初始窗口或窗口下滚</td><td>AL=下滚行数<br>CX=左上角行、列号<br>DX=右下角行、列号<br>BH=空白行的属性</td><td>无</td></tr><tr><td>8</td><td>读取当前光标位置的字符和属性</td><td>BH=页号</td><td>AH=字符码<br>BL=字符属性</td></tr><tr><td>9</td><td>在当前光标位置写字符和属性</td><td>BH=页号<br>AL=字符码<br>BL=字符属性<br>CX=写入字符重复次数</td><td>无</td></tr></tbody></table></div><h3 id="3、DOS-显示功能调用"><a href="#3、DOS-显示功能调用" class="headerlink" title="3、DOS 显示功能调用"></a>3、DOS 显示功能调用</h3><div class="table-container"><table><thead><tr><th>AH</th><th>功能</th><th>调用参数</th><th>返回参数</th></tr></thead><tbody><tr><td>2</td><td>显示一个字符（检查Ctrl+Break）</td><td>DL=字符，光标跟随移动</td><td>无</td></tr><tr><td>6</td><td>显示一个字符（不检查CB）</td><td>DL=字符，光标跟随移动</td><td>无</td></tr><tr><td>9</td><td>显示字符串</td><td>DS:DX=串地址，必须以”$“结尾</td><td>无</td></tr></tbody></table></div><h2 id="四-串行通信口-I-O"><a href="#四-串行通信口-I-O" class="headerlink" title="四 串行通信口 I/O"></a>四 串行通信口 I/O</h2><p>并行通信：多位数据通过多条数据线同时传送<br>串行通信：多位数据通过同一条数据线传送<br>通信方式：单工、半双工、全双工</p><p>串行通信又分为两种类型：同步通信和异步通信。异步通信每个字符单独传输，而同步通信每个字符连接成数据块（信息帧）进行传输。</p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107190702509.png" alt="异步通信"></p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107190833365.png" alt="同步通信"></p><p>波特率：指计算机中每秒传送数据的位数</p><p>使用 DOS 命令可以设置串行通信参数：波特率、校验位、字长和终止位<br>格式：<code>MODE COMm:b, p, d, s</code>。其中 <code>b</code> 指波特率，用波特率的最高两位来表示；<code>p</code> 指校验位，<code>n/o/e</code> 分别表示无校验、奇校验、偶校验；<code>d</code> 指数据的字长；<code>s</code> 指终止位位数，可以为1、1.5或2</p><p><strong>DOS串行通信功能调用</strong></p><div class="table-container"><table><thead><tr><th>AH</th><th>功能</th><th>调用参数</th><th>返回参数</th></tr></thead><tbody><tr><td>3</td><td>从串行口读取字符</td><td></td><td>AL=输入的数据</td></tr><tr><td>4</td><td>向串行口写入字符</td><td>DL=输出的数据</td></tr></tbody></table></div><h2 id="五-文件-I-O"><a href="#五-文件-I-O" class="headerlink" title="五 文件 I/O"></a>五 文件 I/O</h2><p>文件操作可以使用 BIOS 的INT 13H，或 DOS 的INT 21H，只介绍 DOS 提供的文件操作。</p><h3 id="1、预备知识"><a href="#1、预备知识" class="headerlink" title="1、预备知识"></a>1、预备知识</h3><h4 id="（1）路径名和-ASCIZ-串"><a href="#（1）路径名和-ASCIZ-串" class="headerlink" title="（1）路径名和 ASCIZ 串"></a>（1）路径名和 ASCIZ 串</h4><p>asciz 串是一个关于文件位置的字符串，但其最后一个字节必须为 0，可定义成如下形式</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">filename db &#39;d:\test\a.txt&#39;, 00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>DOS 得到文件路径名之后，会得到一个文件代号用来唯一的表示文件。其中 0-4 的文件代号已固定，且长期处于打开状态。最多同时打开 5 个文件。</p><h4 id="（2）错误返回码"><a href="#（2）错误返回码" class="headerlink" title="（2）错误返回码"></a>（2）错误返回码</h4><p>对文件进行操作得到的返回参数中，CF=0 表示操作成功，CF=1 表示操作失败。而错误类型码保存在 AX 寄存器中。</p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107192719130.png" alt="错误类型码"></p><h4 id="（3）文件属性"><a href="#（3）文件属性" class="headerlink" title="（3）文件属性"></a>（3）文件属性</h4><p>每个文件都拥有自己的属性，使用字节表示，存放在 CX 寄存器中</p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107194158430.png" alt="文件属性字节"></p><p>其中常用的有普通文件（00H），只读文件（01H），隐藏文件（02H），只读隐藏系统文件（07H）</p><h4 id="（4）文件指针"><a href="#（4）文件指针" class="headerlink" title="（4）文件指针"></a>（4）文件指针</h4><p>文件指针用来指示当前在文件中的位置，其实一个 32 位二进制数，建立或打开文件后文件指针初值为 0，且每次文件指针的移动位移量等于读写文件的字节数。</p><h3 id="2、常用文件处理命令"><a href="#2、常用文件处理命令" class="headerlink" title="2、常用文件处理命令"></a>2、常用文件处理命令</h3><div class="table-container"><table><thead><tr><th>AH</th><th>功能</th><th>入口参数</th><th>出口参数</th></tr></thead><tbody><tr><td>3CH</td><td>建立文件</td><td>CX=文件属性  DS：DX=文件说明地址</td><td>CF=0，调用成功，AX=文件代号  CF=1，调用失败，AX=错误代码</td></tr><tr><td>3DH</td><td>打开文件</td><td>AL=存取代码  DS：DX=文件说明地址</td><td>CF=0，调用成功，AX=文件代号  CF=1，调用失败，AX=错误代码</td></tr><tr><td>3EH</td><td>关闭文件</td><td>BX=文件代号</td><td>CF=0，调用成功  CF=1，调用失败，AX=错误代码</td></tr><tr><td>3FH</td><td>读文件</td><td>BX=文件代号  CX=读文件的字节数  DS：DX=文件缓冲区地址</td><td>CF=0，调用成功，AX=实际读入的字节数  CF=1，调用失败，AX=错误代码</td></tr><tr><td>40H</td><td>写文件</td><td>BX=文件代号  CX=写文件的字节数  DS：DX=文件缓冲区地址</td><td>CF=0，调用成功，AX=实际写入的字节数  CF=1，调用失败，AX=错误代码</td></tr><tr><td>42H</td><td>移动文件指针</td><td>BX=文件代号  AL=移动方式  CX：DX=移动字节数</td><td>CF=0，调用成功，DX：AX=指针新位置  CF=1，调用失败，AX=错误代码</td></tr><tr><td>43H</td><td>读写文件属性</td><td>AL=0检验/1置文件属性  CX=文件属性  DS：DX=文件说明地址</td><td>CF=0，调用成功，AX=文件属性  CF=1，调用失败，AX=错误代码</td></tr></tbody></table></div><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107195124137.png" alt="文件存取代码"></p><p><img src="/2021/01/07/9-bios-he-dos-gong-neng-diao-yong/image-20210107195505397.png" alt="其他操作"></p><p>复习完结撒花 \\（^ v ^）/***</p>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8——输入输出程序设计</title>
      <link href="2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/"/>
      <url>2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="第八讲-输入输出程序设计"><a href="#第八讲-输入输出程序设计" class="headerlink" title="第八讲 输入输出程序设计"></a>第八讲 输入输出程序设计</h1><p>该部分介绍了 I/O 设备的三种数据传送方式，重点掌握程序直接控制 I/O 方式以及中断传送方式。</p><p>外设通过接口连接至计算机系统中，每个接口由一组寄存器组成，每个寄存器都被分配有 I/O 端口地址。CPU 通过不同的端口控制外设，80x86中，I/O端口位于独立地址空间中，该空间允许设置 64K 个 8 位端口，或 32K 个 16 位端口。</p><p>CPU 与外设之间交换的信息有数据信息、状态信息和控制信息三种，通过不同的端口进行数据传送。而传送信息的方式有<strong>直接存储器存取（DMA）方式</strong>、<strong>程序直接控制I/O方式</strong>和<strong>中断处理方式</strong></p><h2 id="一-直接存储器存取（DMA）方式"><a href="#一-直接存储器存取（DMA）方式" class="headerlink" title="一 直接存储器存取（DMA）方式"></a>一 直接存储器存取（DMA）方式</h2><p>DMA方式可以脱离 CPU 的控制，利用DMA控制器（DMAC），实现外部设备与内存间的直接数据传输，用于磁盘、模数转换器等高速 I/O 设备。</p><ul><li>DMA 模式下，CPU 向 DMAC 下达命令，随后 DMAC 直接进行数据传送，传送完毕后通知 CPU，大大节省系统资源</li><li>DMAC 包括<strong>控制寄存器</strong>、<strong>状态寄存器</strong>、<strong>地址寄存器</strong>和<strong>字节寄存器</strong></li><li>DMA 传输前，CPU 需将总线控制权移交至 DMAC，传输完毕后再交还总线控制权</li></ul><p>DMA 传送步骤：</p><ol><li>总线请求：DMAC 向 CPU 申请总线控制权</li><li>总线控制转移：CPU 同意 DMAC 管理总线</li><li>数据传送：<ol><li>传输数据首地址从地址寄存器中发出</li><li>传输数据字节</li><li>地址寄存器加1</li><li>字节寄存器减1</li></ol></li><li>结束处理：DMAC 放弃总线控制权</li></ol><h2 id="二-程序直接控制-I-O-方式"><a href="#二-程序直接控制-I-O-方式" class="headerlink" title="二 程序直接控制 I/O 方式"></a>二 程序直接控制 I/O 方式</h2><p>前言中我们已得知，计算机内部有独立的端口地址空间。对 I/O 端口进行数据写入与读出时，首先需要寻址。有两种寻址方式</p><ul><li>直接寻址：仅可寻址 00H-0FFH 前 256 个端口，操作数表示端口号</li><li>间接寻址：用于寻址所有端口，DX 寄存器的值就是端口号</li></ul><p><code>IN</code> 指令负责从 I/O 端口向 CPU 读入数据，<code>OUT</code> 端口负责从 CPU 向端口写入数据</p><ul><li><p><code>in al, port</code></p><p>  （al）&lt;-（port）</p></li><li><p><code>in ax, port</code></p><p>  （ax）&lt;-（port+1，port）</p></li><li><p><code>in al, dx</code></p><p>  （al）&lt;-（（dx））</p></li><li><p><code>in ax, dx</code></p><p>  （ax）&lt;-（（dx）+1，（dx））</p></li></ul><p>其中 port 表示立即数，即直接寻址。上述示例了直接寻址、间接寻址、读取8位端口、读取16位端口的不同组合。</p><ul><li><p><code>out port, al</code></p><p>  （port）&lt;-（al）</p></li><li><p><code>out port, ax</code></p><p>  （port+1，port）&lt;-（ax）</p></li><li><p><code>out dx, al</code></p><p>  （（dx））&lt;-（al）</p></li><li><p><code>out dx, ax</code></p><p>  （（dx）+1，（dx））&lt;-（ax）</p></li></ul><h2 id="三-中断传送方式"><a href="#三-中断传送方式" class="headerlink" title="三 中断传送方式"></a>三 中断传送方式</h2><p>CPU 执行程序时，由于外界需要向 CPU 发出申请，CPU 暂停当前程序执行中断服务程序，处理完成后继续被中断程序的过程称为<strong>中断</strong>。8086 可以管理 256 个中断。</p><h3 id="1、中断分类"><a href="#1、中断分类" class="headerlink" title="1、中断分类"></a>1、中断分类</h3><p>中断分为软件中断（内中断）和硬件中断（外中断）</p><ul><li>软件中断：由程序安排的中断或 CPU 错误，DEBUG 设置产生的中断。有除法错误中断（0）、单步中断（1）、单步中断（3）、溢出中断（4）和指令中断（n）。其中除单步中断外，任何中断无法禁止；除单步中断外，任何内中断优先级高于外中断。</li><li>硬件中断：由外部硬件产生的中断。存在<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断（NMI）</strong>，判断标准为是否受 IF 标志的屏蔽，整个系统仅有 1 个NMI。</li></ul><p><img src="/2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/image-20210106194352963.png" alt="软硬中断关系图"></p><h4 id="（1）内中断："><a href="#（1）内中断：" class="headerlink" title="（1）内中断："></a>（1）内中断：</h4><ul><li><p><code>int n</code></p><p>  （sp）&lt;-（sp）-2，（（sp）+1，（sp））&lt;-（flags）</p><p>   IF&lt;-0，TF&lt;-0</p><p>  （sp）&lt;-（sp）-2，（（sp）+1，（sp））&lt;-（cs）</p><p>  （sp）&lt;-（sp）-2，（（sp）+1，（sp））&lt;-（ip）</p><p>  （ip）&lt;-（4*n+1，4*n）</p><p>  （cs）&lt;-（4*n+3，4*n+2）</p></li><li><p><code>iret</code></p><p>  （ip）&lt;-（（sp）+1，（sp）），（sp）&lt;-（sp）+2</p><p>  （cs）&lt;-（（sp）+1，（sp）），（sp）&lt;-（sp）+2</p><p>  （flags）&lt;-（（sp）+1，（sp）），（sp）&lt;-（sp）+2</p></li></ul><h4 id="（2）外中断"><a href="#（2）外中断" class="headerlink" title="（2）外中断"></a>（2）外中断</h4><p>这里主要讨论可屏蔽中断（INTR）</p><p>8259A负责接收外部设备的中断请求，并对优先级进行排序，向 CPU 发送中断请求，若 CPU 相应该请求，则转入中断处理程序。每个 8295A 有 8 个中断请求输入端，因此单个 8259A 可以处理 8 级中断，可以通过级联管理 64 个中断。</p><p>CPU 是否相应外中断，由两个控制条件：</p><ol><li>8259A 是否屏蔽该外设的中断请求</li><li>CPU 是否允许中断请求</li></ol><p>8259A 存在中断屏蔽器（IMR），其 I/O 地址是 21H，其 8 位对应控制 8 个外部设备，某一位 0 表示允许中断，1 表示禁止中断。</p><p><img src="/2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/image-20210106201811413.png" alt="8259A中断屏蔽寄存器"></p><p>而 CPU 的 IF 位为 1 时允许中断，为 0 时禁止中断，分别可以通过 STI 和 CLI 指令进行设置。</p><p>中断处理结束前，需向 8259A 的中断命令寄存器发送终端结束命令（EOI），当EOI 为 1 时，当前正在处理中断被清除。中断命令寄存器的 I/O 端口地址为 20H，其中 L2-L0 用于设置 IR0-IR7 中最低优先级的中断请求，第 6-7 位控制优先级顺序。</p><p><img src="/2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/image-20210106202157996.png" alt="8259A中断命令寄存器"></p><p>响应<strong>外中断</strong>基本步骤：</p><ol><li>响应中断</li><li>标志寄存器入栈</li><li>IF 和 TF 清零</li><li>CS 和 IP 入栈</li><li>根据中断码找到中断程序入口</li><li>执行中断服务程序</li><li>回复 IP 和 CS</li><li>回复标志寄存器</li><li>返回原程序</li></ol><p><img src="/2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/image-20210106202744418.png" alt="中断优先级"></p><p>其中正常情况下 INTR 的优先级由高到低依次为 IR0-IR7</p><h2 id="四-中断程序设计"><a href="#四-中断程序设计" class="headerlink" title="四 中断程序设计"></a>四 中断程序设计</h2><h3 id="1、中断向量表"><a href="#1、中断向量表" class="headerlink" title="1、中断向量表"></a>1、中断向量表</h3><p>8086/8088 内存的前 1K（0000H-03FFH） 字节为中断向量表，划分为 256 项，对应 0-255 号中断。每一项占用 4 个字节单元，高字存储中断服务程序入口段地址，低字存储偏移地址。</p><p>若终端号为 n，则该对应的中断处理程序在向量表中的位置为：<br>（4*n+1，4*n）&lt;-（ip）<br>（4*n+3，4*n+2）&lt;-（cs）</p><h3 id="2、设置中断向量"><a href="#2、设置中断向量" class="headerlink" title="2、设置中断向量"></a>2、设置中断向量</h3><p>当自己编写中断服务程序时，需注意保存原有中断向量，并及时恢复，即“保存-&gt;设置-&gt;恢复”。</p><p><img src="/2021/01/06/8-shu-ru-shu-chu-cheng-xu-she-ji/image-20210106203942646.png" alt="中断向量分配表"></p><h4 id="（1）手动法"><a href="#（1）手动法" class="headerlink" title="（1）手动法"></a>（1）手动法</h4><p>假设需要设置中断号为 n 的中断服务程序</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax, 0mov es, axmov bx, n*4mov ax, offset MyIntProcess; 移入偏移地址mov es: word ptr [bx], axmov ax, seg MyIntProcess; 移入段地址mov es: word ptr [bx+2], axMyIntProcess proc far; 自定义中断服务程序...iretMyIntProcess endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（2）dos-法"><a href="#（2）dos-法" class="headerlink" title="（2）dos 法"></a>（2）dos 法</h4><ul><li><p>使用 dos 21 号中断的 25h 号功能来设置中断向量</p><p>  AH=25H，AL=中断号，DS：DX=中断向量，执行INT 21H</p></li><li><p>使用 dos 21 号中断的 35h 号功能来获得中断向量</p><p>  AH=35H，AL=中断号，执行INT 21H，ES：BX中放入中断向量</p></li></ul><h3 id="3、中断处理程序的结构"><a href="#3、中断处理程序的结构" class="headerlink" title="3、中断处理程序的结构"></a>3、中断处理程序的结构</h3><p>主程序中相关操作：</p><ul><li>设置中断向量</li><li>设置 CPU 的中断允许位 IF</li><li>设置设备的中断屏蔽位</li></ul><p>子程序设计：</p><ol><li>保存寄存器内容</li><li>若允许中断嵌套则开中断（STI）</li><li>实现中断处理功能</li><li>关闭中断（CLI）</li><li>传递中断结束命令（EOI）给中断命令寄存器</li><li>恢复寄存器内容</li><li>IRET 返回</li></ol><p>实例：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">intprg proc farsti; 若允许中断嵌套pusha; 保存现场...; 实现中断处理功能cli; 关闭中断mov al, 20h; 传递中断结束命令out 20h, alpopa; 恢复现场iret; 返回intprg endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7——宏</title>
      <link href="2021/01/06/7-hong/"/>
      <url>2021/01/06/7-hong/</url>
      
        <content type="html"><![CDATA[<h1 id="第七讲-宏"><a href="#第七讲-宏" class="headerlink" title="第七讲 宏"></a>第七讲 宏</h1><h2 id="一-宏"><a href="#一-宏" class="headerlink" title="一 宏"></a>一 宏</h2><p>宏的使用有两部分，一部分为宏定义，宏定义中宏体为主要内容，另一部分为宏调用。汇编时，宏定义消失，宏调用（宏指令）由宏体取代。在宏定义或宏调用语句中，存在具有特殊功能的操作符可供调用。为解决标号问题，提出了 <code>local</code> 宏指令。与子程序类似，宏也存在嵌套问题，需注意相关规范。宏与子程序都辅助人们更好的编写程序，但是各有侧重。</p><h3 id="1、宏定义："><a href="#1、宏定义：" class="headerlink" title="1、宏定义："></a>1、宏定义：</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MacroName macro [params]...endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>宏体是由指令、伪指令以及宏指令构成的程序段。</li><li>实参和形参的数目可以不同，若实参多于形参，则多余参数被忽略，若实参少于形参，则对应形参被置空。</li><li>宏定义需置于宏调用之前的任何位置。</li><li>实参可以为任意字符。</li><li>汇编程序会对源代码进行宏展开，即用相应宏体代替宏指令，并用实参代替宏体中的形参。因此应保证实参代替形参后，宏体中语句仍有效。</li></ul><h3 id="2、相关操作符"><a href="#2、相关操作符" class="headerlink" title="2、相关操作符"></a>2、相关操作符</h3><ul><li><p>连接操作符 <code>&amp;</code></p><p>  在宏体中，使用连接操作符 <code>&amp;</code> 作为形参的前缀，在宏展开时 <code>&amp;</code> 前后的两个符号会连接。其也可作为形参的后缀。</p></li><li><p>表达式操作符 <code>%</code></p><p>  在宏调用时，若实参为表达式，该操作符可用于表达式之前，强迫表达式立即求值，并将结果作为实参。</p></li><li><p>转义操作符 <code>!</code></p><p>  用于宏调用的实参之前，表示使用其后紧邻字符的本义。</p></li><li><p><code>LOCAL</code> 伪指令</p>  <pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MName macro [params list]local [label list]label1:label2:...endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  标号表中各标号使用逗号分隔。<code>local</code> 伪操作仅用于宏定义中，其必须紧邻 <code>macro</code> 伪指令之后，中间不得有注释以及分号。处理宏调用时，汇编程序将用 ??0000、??0001 等来代替标号。</p></li></ul><h3 id="3、宏嵌套"><a href="#3、宏嵌套" class="headerlink" title="3、宏嵌套"></a>3、宏嵌套</h3><p>宏嵌套有两种形式，其一为宏体中包括宏定义，其二是宏体中包括宏调用，此时其调用的宏指令必须已经定义完成。</p><h3 id="4、宏定义与子程序的区别"><a href="#4、宏定义与子程序的区别" class="headerlink" title="4、宏定义与子程序的区别"></a>4、宏定义与子程序的区别</h3><ul><li>处理时间：宏调用在汇编时由汇编程序处理，而子程序调用则由CPU执行</li><li>处理方式：宏定义实质上是对源代码的文本替换，而子程序是CS：IP地址的转换</li><li>参数处理：宏调用采用字符串进行传参，而子程序需要借助寄存器或内存</li><li>执行速度：子程序需要调用call和ret指令以及传参操作，相比宏调用稍慢</li><li>占用空间：宏指令由于会出现多次文本替换，因此其占用内存空间较大，而子程序代码仅会出现一次，因此占用空间小</li></ul><p>宏是源程序级的简化，子程序是目标程序级的简化。模块化结构设计时多采用子程序，而非标准程序段且代码量小、调用次数少，或功能明确的代码可采用宏。</p><h2 id="二-重复汇编"><a href="#二-重复汇编" class="headerlink" title="二 重复汇编"></a>二 重复汇编</h2><p>重复汇编用于生成连续且完全相同或几乎完全相同的一组代码。</p><h4 id="1、rept"><a href="#1、rept" class="headerlink" title="1、rept"></a>1、rept</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">rept 整数表达式重复体endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重复重复体 n 次，n 为整数表达式的值。</p><p>应用</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">x &#x3D; 0rept 10x &#x3D; x + 1db xendm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、irp"><a href="#2、irp" class="headerlink" title="2、irp"></a>2、irp</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">irp 形参, &lt;实参列表&gt;重复体endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重复重复体，依次取实参列表中的实参代替重复体中的形参。</p><p>应用</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">irp x, &lt;ax, bx, cx, cx&gt;push xendm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3、irpc"><a href="#3、irpc" class="headerlink" title="3、irpc"></a>3、irpc</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">irpc 形参, 字符串重复体endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重复重复体，依次取字符串中的字符取代重复体中形参。</p><p>应用</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">irpc x, 0123456789db xendm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三-库的使用"><a href="#三-库的使用" class="headerlink" title="三 库的使用"></a>三 库的使用</h3><p>宏库扩展名为 “*.mac”，可以使用 <code>include</code> 伪指令来引用宏库，调用格式为 <code>include [文件路径]</code>。可以使用 <code>purge</code> 语句取消宏定义，形如 <code>purge mName1, mName2, ...</code>。</p><p>宏指令名可以与指令或伪指令同名，且宏指令名优先级更高。同样的，可以使用 <code>purge</code> 在某一位置之后清除已定义的宏。</p>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6——子程序结构</title>
      <link href="2021/01/05/6-zi-cheng-xu-jie-gou/"/>
      <url>2021/01/05/6-zi-cheng-xu-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="第六讲-子程序结构"><a href="#第六讲-子程序结构" class="headerlink" title="第六讲 子程序结构"></a>第六讲 子程序结构</h1><h2 id="一-子程序定义"><a href="#一-子程序定义" class="headerlink" title="一 子程序定义"></a>一 子程序定义</h2><p>子程序定义由伪指令 <code>PROC</code> 和 <code>ENDP</code> 实现，基本格式如下</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">processName proc [near|far]...retprocessName endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>NEAR</code> 属性：该子程序仅可被相同代码段的其他程序调用</li><li><code>FAR</code> 属性：可以被相同代码段或不同代码段的程序调用</li></ul><h2 id="二-子程序的调用与返回"><a href="#二-子程序的调用与返回" class="headerlink" title="二 子程序的调用与返回"></a>二 子程序的调用与返回</h2><p>子程序调用指令首先将子程序返回地址压入栈中，随后转移到子程序的入口地址执行子程序，分为段内调用和段外调用。子程序返回指令则将压入栈中的返回地址弹出到 IP 地址或 CS：IP中，随后正常执行。</p><p>子程序调用，其指令格式为 <code>call near|far ptr processName</code></p><ul><li><p><code>call near ptr processName</code></p><p>  1、（ip）入栈</p><p>  2、（ip）&lt;-offset processName</p></li><li><p><code>call far ptr processName</code></p><p>  1、（cs、ip）入栈</p><p>  2、（cs、ip）&lt;-（seg processName、offset processName）</p></li></ul><p>子程序返回，其指令格式为<code>ret [val]</code></p><ul><li><p>段内返回</p><p>  1、（ip）&lt;-（sp+1，sp）</p><p>  2、（sp）&lt;-（sp）+2+val</p></li><li><p>段间返回</p><p>  1、（ip）&lt;-（sp+1，sp）</p><p>  2、（sp）&lt;-（sp）+2</p><p>  3、（cs）&lt;-（sp+1，sp）</p><p>  4、（sp）&lt;-（sp）+2+val</p></li></ul><p>需要注意寄存器的保护工作，存在<strong>堆栈保护</strong>和<strong>内存保护</strong>两种保护方式，同时，保护工作既可以在主程序中，也可以在子程序中，但需在同一部分实现。</p><h2 id="三-子程序设计方法"><a href="#三-子程序设计方法" class="headerlink" title="三 子程序设计方法"></a>三 子程序设计方法</h2><p>子程序位置：可以在 <code>mov ah 4ch//int 21h</code> 之后，或者是在主程序开始位置 <code>start</code> 之前，不可以出现在主程序中间位置。</p><p>子程序说明：子程序前关于下列属性的说明：子程序名、子程序功能、入口参数、出口参数、受影响寄存器</p><p>子程序传参：四种传参方式：寄存器法、变量传递法、堆栈法、参数地址指针法</p><ul><li>寄存器法：约定特定的寄存器中存储入口、出口参数</li><li>变量传递法：使用变量名来传递参数</li><li>堆栈法：将入口、出口参数放入栈中（涉及到 sp、bp 的使用）</li><li>参数地址指针法：将参数地址通过寄存器传入子程序中</li></ul><h2 id="四-子程序嵌套与递归"><a href="#四-子程序嵌套与递归" class="headerlink" title="四 子程序嵌套与递归"></a>四 子程序嵌套与递归</h2><p>需注意嵌套深度需在栈空间内以及递归终止条件</p><h2 id="五-子程序的连接"><a href="#五-子程序的连接" class="headerlink" title="五 子程序的连接"></a>五 子程序的连接</h2><p>大型应用程序开发过程中采用模块化的开发方式，各模块之间存在相互调用，一个模块会调用另一个模块的标识符（变量、标号、过程名等）</p><p>标识符分为两种，在本模块内使用的称为局部标识符，在一个模块定义，在另一个模块引用的称为外部标识符。</p><p>模块连接方法：</p><ul><li><p><code>include filename.asm</code> 伪指令</p><p>  该指令负责将独立编制好的 .asm 文件在汇编时简单拼接在一起，其实质是在 <code>include filename.asm</code> 指令位置嵌入 filename.asm 文件文本，被包含文件无法单独汇编，且存在标识符冲突问题。</p></li><li><p>使用 <code>link</code> masm 指令进行连接</p><p>  在 dos 系统下，使用 <code>link fn1.obj fn2.obj ...</code> 指令可以将多个 .obj 文件连接在一起。要求各源程序均能单独汇编（存在必备的段），模块中需使用 <code>extrn</code> 和 <code>public</code> 标号，且两个标号需放在所有段之前。</p></li></ul><p>共用标号的声明：</p><ul><li><p><code>public 标识符[,标识符]</code></p><p>  表示将本模块中的标识符进行共享</p></li><li><p><code>extrn 标识符:类型 [,标识符:类型]</code></p><p>  类型是 byte/word/dword 或 near/far，在一个源程序中 <code>public</code> 和 <code>extrn</code> 可以拥有多条</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5——循环与分支结构设计</title>
      <link href="2021/01/05/5-xun-huan-yu-fen-zhi-jie-gou-she-ji/"/>
      <url>2021/01/05/5-xun-huan-yu-fen-zhi-jie-gou-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="五-循环与分支结构设计"><a href="#五-循环与分支结构设计" class="headerlink" title="五 循环与分支结构设计"></a>五 循环与分支结构设计</h1><p>在汇编语言中，存在顺序执行、分支语句和循环语句三种程序执行结构，可以使用转移指令来实现分支语句，使用转移指令或循环指令来实现循环语句。</p><h2 id="一-控制转移指令"><a href="#一-控制转移指令" class="headerlink" title="一 控制转移指令"></a>一 控制转移指令</h2><h3 id="1-无条件转移指令"><a href="#1-无条件转移指令" class="headerlink" title="1 无条件转移指令"></a>1 无条件转移指令</h3><div class="table-container"><table><thead><tr><th>指令名称</th><th>指令格式</th><th>指令效果</th></tr></thead><tbody><tr><td>段内直接短转移</td><td>jmp short opr</td><td>（ip）&lt;-（ip）+8位位移量</td></tr><tr><td>段内直接近转移</td><td>jmp near ptr opr</td><td>（ip）&lt;-（ip）+16位位移量</td></tr><tr><td>段内间接转移</td><td>jmp word ptr opr</td><td>（ip）&lt;-（EA）</td></tr><tr><td>段间直接转移</td><td>jmp far ptr opr</td><td>（ip）&lt;-opr偏移地址<br>（cs）&lt;-opr段地址</td></tr><tr><td>段间间接转移</td><td>jmp dword ptr opr</td><td>（ip）&lt;-（EA）<br>（cs）&lt;-（EA+2）</td></tr></tbody></table></div><h3 id="2-条件转移指令"><a href="#2-条件转移指令" class="headerlink" title="2 条件转移指令"></a>2 条件转移指令</h3><div class="table-container"><table><thead><tr><th>指令名称</th><th>检测条件</th><th>转移条件</th></tr></thead><tbody><tr><td>jz、je</td><td>zf=1</td><td>结果为0或相等</td></tr><tr><td>jnz、jne</td><td>zf=0</td><td>结果不为0或不等</td></tr><tr><td>js</td><td>sf=1</td><td>结果为负</td></tr><tr><td>jns</td><td>sf=0</td><td>结果为正</td></tr><tr><td>jc</td><td>cf=1</td><td>有进位或借位</td></tr><tr><td>jnc</td><td>cf=0</td><td>无进位或借位</td></tr><tr><td>jo</td><td>of=1</td><td>运算有溢出</td></tr><tr><td>jno</td><td>of=0</td><td>运算无溢出</td></tr><tr><td>jp、jpe</td><td>pf=1</td><td>有偶数个1</td></tr><tr><td>jnp、jpo</td><td>pf=0</td><td>有奇数个1</td></tr><tr><td>jb、jnae</td><td>cf=1</td><td>无符号低于</td></tr><tr><td>jnb、jae</td><td>cf=0</td><td>无符号不低于</td></tr><tr><td>jbe、jna</td><td>cf=1或zf=1</td><td>无符号低于等于</td></tr><tr><td>jnbe、ja</td><td>cf=0且zf=0</td><td>无符号大于</td></tr><tr><td>jl、jnge</td><td>sf$\otimes$of=1</td><td>算数小于</td></tr><tr><td>jnl、jge</td><td>sf$\otimes$of=0</td><td>算数大于等于</td></tr><tr><td>jg、jnle</td><td>（sf$\otimes$of=0）<br>且zf=0</td><td>算数大于</td></tr><tr><td>jng、jle</td><td>sf$\otimes$of=1<br>或zf=1</td><td>算数小于等于</td></tr></tbody></table></div><h3 id="3-循环指令"><a href="#3-循环指令" class="headerlink" title="3 循环指令"></a>3 循环指令</h3><div class="table-container"><table><thead><tr><th>指令名称</th><th>检测条件</th></tr></thead><tbody><tr><td>loop</td><td>$cx\neq0$</td></tr><tr><td>loope、loopz</td><td>$cx\neq0$ 且 $zf=1$</td></tr><tr><td>loopne、loopnz</td><td>$cx\neq0$ 且 $zf=0$</td></tr></tbody></table></div><h3 id="二-循环基本结构"><a href="#二-循环基本结构" class="headerlink" title="二 循环基本结构"></a>二 循环基本结构</h3><ul><li><p>循环初始化部分：</p><p>  在该部分对需要处理的数据进行初始化，同时对循环次数等进行初始化，且必要的话需要进行数据保护</p></li><li><p>循环体：</p><p>  在该部分实现待完成的工作</p></li><li><p>循环修改部分：</p><p>  修改循环相关量，如地址、计数器等</p></li><li><p>循环控制部分：</p><p>  在该部分处理循环和退出循环的逻辑判断</p></li></ul><h3 id="三-分支结构程序设计"><a href="#三-分支结构程序设计" class="headerlink" title="三 分支结构程序设计"></a>三 分支结构程序设计</h3><ul><li><p>双分支结构：用于 $if$ 结构，或 $if-else$ 结构</p></li><li><p>多分支语句：</p><ul><li>使用双分支语句嵌套实现多分支</li><li>进行逻辑分解，顺序执行，至到满足条件再进行跳转</li><li>跳跃表法，将每段分支程序的入口放入跳跃表中</li><li>转移表法：将每段分支程序对应跳转语句的地址放入转移表中</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4——汇编指令</title>
      <link href="2021/01/05/4-hui-bian-zhi-ling/"/>
      <url>2021/01/05/4-hui-bian-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="第四讲-指令"><a href="#第四讲-指令" class="headerlink" title="第四讲 指令"></a>第四讲 指令</h1><h2 id="一-数据传送指令"><a href="#一-数据传送指令" class="headerlink" title="一 数据传送指令"></a>一 数据传送指令</h2><ul><li><p>MOV DST，SRC</p><p>  功能：（DST）&lt;-（SRC）</p><p>  操作数：操作数不能同时为段寄存器和存储器，立即数不能直接送至段寄存器，DST不得为CS和立即数</p></li><li><p>PUSH SRC</p><p>  功能：（SP）&lt;-（SP）-2，（（SP+1），（SP））&lt;-（SRC）</p><p>  操作数：必须为字类型，寄存器，存储器</p></li><li><p>POP DST</p><p>  功能：（DST）&lt;-（（SP+1），（SP）），（SP）&lt;-（SP+2）</p><p>  操作数：子类型的寄存器或存储器，DST不得为CS</p></li><li><p>PUSHA</p><p>  功能：AX、CX、DX、BX、SP、BP、SI、DI依次入栈</p><p>  操作数：无</p></li><li><p>POPA</p><p>  类比 PUSHA 即可</p></li><li><p>XCHG OPR1，OPR2</p><p>  功能：（OPR1）&lt;-&gt;（OPR2）</p><p>  操作数：两个操作数中必须有一个为寄存器，不得为段寄存器</p></li><li><p>XLAT（换码指令）</p><p>  功能：（AL）&lt;-（（AL）+（BX）），可用于代码转换，如0-9转7段数码管</p><p>  操作数：无</p></li><li><p>LEA REG，SRC</p><p>  功能：（REG）&lt;-SRC的有效地址</p><p>  操作数：SRC为存储器，REG不得为段存储器</p></li><li><p>LDS REG，SRC</p><p>  功能：（REG）&lt;-（SRC），（DS）&lt;-（SRC+2）</p><p>  操作数：同上</p></li><li><p>LES REG，SRC</p><p>  功能：（REG）&lt;-（SRC），（ES）&lt;-（SRC+2）</p><p>  操作数：同上</p></li><li><p>LAHF</p><p>  功能：（AH）&lt;-（FLAGS的低字节）</p></li><li><p>SAHF</p><p>  功能：（FLAGS的低字节）&lt;-（AH）</p></li><li><p>PUSHF</p><p>  功能：（SP）&lt;-（SP）-2，（（SP+1），（SP））&lt;-（FLAGS）</p></li><li><p>POPF</p><p>  功能：与上相反</p><p>  <img src="/2021/01/05/4-hui-bian-zhi-ling/image-20210103142404629.png" alt="16位标志寄存器"></p></li><li><p>CBW</p><p>  功能：若（AL）最高有效位为0，则（AH）&lt;-00H，否则（AH）&lt;-0FFH</p></li><li><p>CWD</p><p>  功能：若（AX）最高有效位为0，则（DX）&lt;-0000H，否则（DX）&lt;-0FFFFH</p></li></ul><h2 id="二-算数指令"><a href="#二-算数指令" class="headerlink" title="二 算数指令"></a>二 算数指令</h2><p>除特殊说明以下指令的操作数：与 MOV 语句操作数条件相同，同时操作数不允许为段寄存器</p><p>除特殊说明以下指令影响的标志位：影响OF，CF，SF，ZF</p><ul><li><p>ADD DST，SRC</p><p>  功能：（DST）&lt;-（DST）+（SRC）</p></li><li><p>ADC DST，SRC</p><p>  功能：（DST）&lt;-（DST）+（SRC）+CF</p></li><li><p>INC OPR</p><p>  功能：（OPR）&lt;-（OPR）+1</p><p>  操作数：OPR为寄存器或存储器，且不能为段寄存器</p><p>  标志位：同上，但不影响CF</p></li><li><p>SUB DST，SRC</p><p>  功能：（DST）&lt;-（DST）-（SRC）</p></li><li><p>SBB DST，SRC</p><p>  功能：（DST）&lt;-（DST）-（SRC）-CF</p></li><li><p>DEC OPR</p><p>  功能：（OPR）&lt;-（OPR）-1</p><p>  操作数：OPR为寄存器或存储器，且不能为段寄存器</p><p>  标志位：不影响CF</p></li><li><p>NEG OPR</p><p>  功能：（OPR）&lt;-0FFFFH-（OPR）+1，可用来求相反数</p><p>  操作数：可微寄存器或存储器，不允许为段寄存器</p><p>  标志位：若操作数为0，则CF为0，否则为1；若操作数为-128或-32768，则OF为1，否则为0</p></li><li><p>CMP OPR1，OPR2</p><p>  功能：（OPR1）-（OPR2）</p></li><li><p>MUL SRC</p><p>  功能：（AX）&lt;-（AL）*（SRC）或（DX，AX）&lt;（AX）*（SRC）</p><p>  操作数：寄存器或存储器，不得为段寄存器和立即数</p><p>  标志位：如果乘积的高一半为0，则（CF，OF）=（0,0）否则（CF，OF）=（1,1）</p></li><li><p>IMUL SRC</p><p>  功能：同上，但其为带符号乘法</p><p>  操作数：寄存器或存储器，不得为段寄存器和立即数</p><p>  标志位：如果乘积的高一半是低一半的成绩扩展，则（CF，OF）=（0,0）否则（CF，OF）=（1,1）</p></li><li><p>DIV SRC</p><p>  功能：（AL）&lt;-（AX）/（SRC），（AH）&lt;-（AX）%（SRC）或</p><p>  （AX）&lt;-（DX，AX）/（SRC），（DX）&lt;-（DX，AX）%（SRC）</p><p>  操作数：同乘法</p><p>  标志位：不影响标志位</p></li><li><p>IDIV SRC</p><p>  同上，该指令为带符号除法</p></li></ul><h2 id="三-逻辑指令"><a href="#三-逻辑指令" class="headerlink" title="三 逻辑指令"></a>三 逻辑指令</h2><p>以下指令除特殊说明外会将 CF，OF 标志位置 0，根据运算结果设置 SF，ZF，PF，功能比较简单，不再介绍。除特殊说明外，其操作数均不允许出现段寄存器，其余和MOV条件相同</p><ul><li><p>NOT OPR</p><p>  操作数：OPR 不能为立即数，段寄存器</p><p>  标志位：不影响标志位</p></li><li><p>AND DST，SRC</p></li><li><p>OR DST，SRC</p></li><li><p>XOR DST，SRC</p></li><li><p>TEST OPR1，OPR2</p><p>  功能：（OPR1）AND（OPR2）</p></li></ul><p>除特殊说明外，对于下列指令，其OPR操作数可用除立即数之外的任何寻址方式，当CNT=1时，可以使用立即数，否则CNT必须为CL。对于条件标志位，CF等于移入数值；当CNT=1时且最高有效位的值发生变化时，OF=1，若CNT=1且最高有效位值不变化时，OF=0；根据结果设置SF，ZF，PF</p><ul><li><p>SHL OPR，CNT</p></li><li><p>SHR OPR，CNT</p></li><li><p>SAL OPR，CNT</p></li><li><p>SAR OPR，CNT</p></li><li><p>ROL OPR，CNT</p></li><li><p>ROR OPR，CNT</p></li><li><p>RCL OPR，CNT</p><p>  不影响标志位SF，ZF，PF，AF</p></li><li><p>RCR OPR，CNT</p><p>  不影响标志位SF，ZF，PF，AF</p><p>  <img src="/2021/01/05/4-hui-bian-zhi-ling/image-20210103153311172.png" alt="祭神图"></p></li></ul><h2 id="四-串处理指令"><a href="#四-串处理指令" class="headerlink" title="四 串处理指令"></a>四 串处理指令</h2><ul><li><p>REP</p><p>  功能：串处理前缀，与MOVS、CMPS、SCAS、LODS、STOS等联用，格式为 REPoperation_expr，每执行一次  expr，CX 减一，直到CX为0为止</p></li><li><p>MOVS/MOVSB/MOVSW DST，SRC</p><p>  功能：（DST）&lt;-（SRC），（DI）&lt;-（DI）±bytes，（SI）&lt;-（SI）±bytes</p><p>  操作数：默认为 DST 为 ES：[DI]，SRC 为 DS：[SI]，仅允许改变 SRC 的段前缀</p><p>  标志位：不影响</p><p>  注：使用 MOVS 时需指定操作数类型（字节或字）</p></li><li><p>STOS/STOSB/STOSW DST</p><p>  功能：（DST）&lt;-（AL/AX/EAX），（DI）&lt;-（DI）±bytes</p><p>  操作数：默认为 ES：[DI]，相信我，你也改不了的。</p></li><li><p>LODS/LODSB/LODSW SRC</p><p>  功能：（AL/AX/EAX）&lt;-（（SI）），（SI）&lt;-（SI）±bytes</p><p>  操作数：默认为 ES：[SI]，可以修改 ES 为 DS</p></li><li><p>REPE/REPZ  expr</p><p>  功能：当 CX 不为 0 且 ZF 不为 0 时循环执行其后的表达式，同时 CX 减一，其后表达式可以为 CMPS 和 SCAS</p></li><li><p>REPNE/REPNZ expr</p><p>  功能：当 CX 不为 0 且 ZF 等于 0 时循环执行其后的表达式，同时 CX 减一，其后表达式可以为 CMPS 和 SCAS</p></li><li><p>CMPS/CMPSB/CMPSW SRC，DST</p><p>  功能：执行 （（SI））-（（DI）），并设置标志位，同时 （SI）和（DI）相应增加或减小</p></li><li><p>SCAS/SCASB/SCASW DST</p><p>  功能：执行（AL）-（（DI）），并设置标志位，同时（DI）相应增加或减小</p></li></ul><h2 id="五-处理机控制与杂项控制指令"><a href="#五-处理机控制与杂项控制指令" class="headerlink" title="五 处理机控制与杂项控制指令"></a>五 处理机控制与杂项控制指令</h2><p>处理机控制指令：</p><ul><li>CLC：CF置0</li><li>STC：CF置1</li><li>CMC：CF求反</li><li>CLD：DF置0</li><li>STD：DF置1</li><li>CLI：IF置0</li><li>STI：IF置1</li></ul><p>CPU 控制指令：</p><ul><li>NOP：不执行任何操作，但占用一个字节存储单元，占用指令执行周期用于调试</li><li>HLT：使CPU暂停工作等待外部中断</li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3——汇编语言基础格式</title>
      <link href="2021/01/02/3-hui-bian-yu-yan-ji-chu-ge-shi/"/>
      <url>2021/01/02/3-hui-bian-yu-yan-ji-chu-ge-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第三讲-汇编语言基础格式"><a href="#第三讲-汇编语言基础格式" class="headerlink" title="第三讲 汇编语言基础格式"></a>第三讲 汇编语言基础格式</h1><h2 id="一-汇编程序功能"><a href="#一-汇编程序功能" class="headerlink" title="一 汇编程序功能"></a>一 汇编程序功能</h2><p>将汇编语言编写的源程序翻译成目标程序的过程称为<strong>汇编</strong>，完成汇编任务的程序称为<strong>汇编程序</strong></p><p><img src="/2021/01/02/3-hui-bian-yu-yan-ji-chu-ge-shi/image-20210102114501025.png" alt="汇编基本流程" style="zoom: 33%;"></p><blockquote><p>注：.obj 文件已经是二进制文件，但其与库文件或其他目标文件连接之后才能形成可执行文件</p></blockquote><h2 id="二-（伪）指令语句基本格式"><a href="#二-（伪）指令语句基本格式" class="headerlink" title="二 （伪）指令语句基本格式"></a>二 （伪）指令语句基本格式</h2><p>伪指令汇编后不产生目标机器码，而每条指令语句都产生对应的机器码；伪指令语句对应的操作在汇编后完成，而指令语句对应操作在运行时完成。</p><p>两者的格式：</p><ul><li>指令语句：<code>[标号名:] 操作码 [操作数] [;注释]</code></li><li>伪指令语句：<code>[变量名] 伪操作码 [操作数] [;注释]</code></li></ul><p>各语言单位：</p><ul><li>操作项：操作项为指令、伪指令、宏指令的操作码，又称助记符</li><li>名字项：名字项为标号名、变量名等，可由字母、数字、特殊字符（?、.、@、-、$）组成。数字不能为首项，. 仅能用作首项、单独的 ? 不能作为名字。</li><li>标号：<u>表示指令所在单元地址，在代码段中定义使用</u>。其可用 <code>LABEL</code> 或 <code>EQU</code> 伪指令定义，常用作 <code>CALL</code> 指令或转移指令操作数字段</li><li>变量：<u>在数据段、附加段和堆栈段中定义。</u>其为数字，数据区和存储区的首地址<ul><li>属性：变量和标号具有段属性、偏移属性和类型属性。段属性为所在段；偏移属性为所在地址距离段基址的偏移量；类型属性有段内引用 <code>NEAR</code>、段外引用 <code>FAR</code>、<code>BYTE</code>、<code>WORD</code>、<code>DWORD</code>、<code>FWORD</code>、<code>QWORD</code>、<code>TBYTE</code></li></ul></li><li>常量：指在汇编器确定的没有任何属性的纯数值，主要用于立即数和伪指令赋初值，有数值常量、字符串常量和符号常量（指EQU伪指令或赋值语句“=”定义过的符号名）。数值常量基数后缀为 “d、b、o/q、h”</li></ul><h3 id="三-伪指令语句"><a href="#三-伪指令语句" class="headerlink" title="三 伪指令语句"></a>三 伪指令语句</h3><p>伪指令不负责程序的运行，而负责目标代码的生成，主要功能有：逻辑段的定义、存储模式定义、数据定义、存储器分配、指示程序开始结束等</p><p>常用伪指令：</p><ul><li><p>段定义伪指令：略。不要忘记存在 <code>assume 段寄存器: nothing</code> 伪指令，其用于取消远端寄存器的指定</p></li><li><p>存储模式伪指令：</p><p>  其通常模式为 <code>.MODEL 存储模式 [,语言类型][,操作系统类型][,堆栈选项]</code></p><p>  存储模式：tiny、small、medium、compact、large、huge、flag</p><p>  语言类型：C、BASIC、PASCAL等</p><p>  操作系统：OS_DOS（默认）或OS_OS2</p><p>  堆栈选项：NEARSTACK将堆栈段和数据段组合至一个DGROUP段中，FARSTACK不进行组合。存储模式为Compact、Large、Huge时默认为 FARSTACK，否则为 NEARSTACK</p><p>  <img src="/2021/01/02/3-hui-bian-yu-yan-ji-chu-ge-shi/image-20210102144852583.png" alt="存储模式介绍" style="zoom: 33%;"></p><p>  使用存储模式伪指令可以使用简化段定义但必须有 <code>.MODEL</code> 语句，若只有 <code>.code</code> 、<code>.stack</code>、<code>.code</code> 则可以省略 <code>assume</code> 语句</p></li><li><p>段组定义伪操作：<code>GroupName Group segname1, segname2,...</code>，</p></li><li><p>数据定义及存储器分配伪操作：助记符 <code>DB</code>、<code>DW</code>、<code>DD</code>、<code>DF</code>、<code>DQ</code>、<code>DT</code></p></li><li><p>复制操作符：<code>RepeatCount dup (num1,num2,...)</code> 可嵌套</p></li><li><p>PTR伪指令：用于指定操作数的数据类型，格式为 <code>type PTR 变量或常量</code></p></li><li><p>LABEL伪操作：指定操作数的数据类型，格式为 <code>name LABEL type</code></p></li><li><p>表达式赋值伪操作：为表达式新定义一个名字，表达式可以为任何有效操作数格式、或可求出常数的表达式、或助记符，格式为<code>ExprName EQU expr</code>。功能与 <code>=</code> 相同，但 <code>=</code> 允许重复定义</p></li><li><p>地址计数器 $：其表示数据或代码的地址。当 <code>$</code> 用在指令中时，其表示本条指令第一个字节的地址，若其在伪指令的参数字段中时，其表示当前数据的地址。</p></li><li><p>ORG伪指令：设定当前地址计数器的值，指定存放指令或数据的位置。<code>ORG expr</code>，表达式需可计算出数值</p></li><li><p>基数控制伪操作：<code>.radix expr</code> ，需要注意，当从 10 进制改为 16 进制时，若原来的 16 进制之后有字母 D，则需在该数后面加上 H</p></li></ul><h2 id="四-表达式操作符"><a href="#四-表达式操作符" class="headerlink" title="四 表达式操作符"></a>四 表达式操作符</h2><p>汇编指令中的操作数项可以为常数、寄存器、标号、变量或表达式。表达式是常数、寄存器、标号、变量以及一些操作符组成的序列，有数字表达式和地址表达式两种。</p><p>表达式常见运算符：</p><ul><li><p>算数运算符：+、-、*、/、Mod</p></li><li><p>关系运算符：EQ、NE、LT、LE、GT、GE，若为真返回 0FFFFH，否则返回 00000H</p></li><li><p>逻辑和移位操作符：AND、OR、XOR、NOT</p></li><li><p>数值回送操作符：TYPE、LENGTH、SIZE、OFFSET、SEG。对于TYPE，其返回值如下表</p><p>  | DB   | DW   | DD   | DF   | DQ   | DT   | NEAR | FAR  | 常数 |<br>  | —— | —— | —— | —— | —— | —— | —— | —— | —— |<br>  | 1    | 2    | 4    | 6    | 8    | 10   | -1   | -2   | 0    |</p></li><li><p>属性操作符：SHORT、HIGH、LOW、HIGHWORD、LOWWORD，其操作对象均需为立即数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2——硬件一览</title>
      <link href="2021/01/02/1-ying-jian-yi-lan/"/>
      <url>2021/01/02/1-ying-jian-yi-lan/</url>
      
        <content type="html"><![CDATA[<h1 id="第一讲-硬件一览"><a href="#第一讲-硬件一览" class="headerlink" title="第一讲 硬件一览"></a>第一讲 硬件一览</h1><h2 id="一-硬件总览"><a href="#一-硬件总览" class="headerlink" title="一 硬件总览"></a>一 硬件总览</h2><p><img src="/2021/01/02/1-ying-jian-yi-lan/image-20210101110944450.png" alt="微机主要设备" style="zoom:50%;"></p><p>微型计算机硬件主要由中央处理机、存储器、系统总线、I/O接口电路和I/O设备组成。</p><ul><li><p>中央处理机</p><p>  集成运算器、控制器和寄存器组，完成算数和逻辑运算以及控制工作。</p></li><li><p>存储器</p><p>  主存（内存），CPU通过总线读写，有ROM和RAM。辅存（外存），CPU通过I/O接口读写。</p></li><li><p>总线</p><ul><li>数据总线（双向总线）</li><li>地址总线（单向总线），直接寻址范围为 $2^n$，8086总线为 20 位</li><li>控制总线（双向总线）</li></ul></li><li><p>I/O接口电路</p><p>  I/O接口电路中每个寄存器统一编号，称为I/O端口地址或端口号，地址空间为 64KB，共 65536 个 I/O 地址，端口地址范围为 0000-FFFFH</p></li><li><p>I/O设备</p><p>  输入输出设备</p></li></ul><h2 id="二-中央处理机与寄存器"><a href="#二-中央处理机与寄存器" class="headerlink" title="二 中央处理机与寄存器"></a>二 中央处理机与寄存器</h2><h3 id="1、中央处理机"><a href="#1、中央处理机" class="headerlink" title="1、中央处理机"></a>1、中央处理机</h3><p><img src="/2021/01/02/1-ying-jian-yi-lan/image-20210101111940167.png" alt="硬件结构图" style="zoom:50%;"></p><p>CPU 功能上可分为<strong>总线接口部件（BIU）</strong>和<strong>执行部件（EU）</strong>。前者负责CPU与存储器、I/O端口传送数据，后者负责指令执行和数据运算。</p><ul><li><p>总线接口部件</p><p>  其含有段寄存器（4个16位寄存器）、指令指针寄存器（16位）、地址加法器（形成20位地址）、指令队列（6字节）和总线接口控制电路。</p></li><li><p>执行部件</p><p>  通用寄存器（数据寄存器和指针与变址寄存器）、标志寄存器（FR）、算术逻辑部件（ALU）和执行部件控制电路。</p></li></ul><h3 id="2、寄存器组"><a href="#2、寄存器组" class="headerlink" title="2、寄存器组"></a>2、寄存器组</h3><h4 id="（1）通用寄存器"><a href="#（1）通用寄存器" class="headerlink" title="（1）通用寄存器"></a>（1）通用寄存器</h4><p><strong>数据寄存器</strong>用来保存操作数或运算结果：</p><div class="table-container"><table><thead><tr><th>寄存器名称</th><th>功能</th></tr></thead><tbody><tr><td>AX（Accumulator）累加器</td><td>算数逻辑运算，与外设传送信息</td></tr><tr><td>BX（Base）基址寄存器</td><td>存放存储器地址</td></tr><tr><td>CX（Count）计数器</td><td>循环和串操作计数器，CL移位指定位数</td></tr><tr><td>DX（Data）数据寄存器</td><td>存放双字数据高16位，乘除运算的参数，存放外设端口地址</td></tr></tbody></table></div><p><strong>变址寄存器</strong>常用于存放某个存储单元偏移位置</p><div class="table-container"><table><thead><tr><th>寄存器名称</th><th>功能</th></tr></thead><tbody><tr><td>SI（Source Index Reg）源变址寄存器</td><td>与DS连用，确定存储单元位置</td></tr><tr><td>DI（Destination Index Reg）目的变址寄存器</td><td>与DS或ES连用，确定单元地址</td></tr></tbody></table></div><blockquote><p>注：变址寄存器不可分割成 8 位寄存器</p></blockquote><p><strong>指针寄存器</strong>常用来访问栈内存储单元</p><div class="table-container"><table><thead><tr><th>寄存器名称</th><th>功能</th></tr></thead><tbody><tr><td>SP（Stack Pointer）堆栈指针寄存器</td><td>通过 SS:SP  来访问栈顶</td></tr><tr><td>BP（Base Pointer）基址指针寄存器</td><td>通过 SS:SP 来访问栈内存储单元</td></tr></tbody></table></div><h4 id="（2）专用寄存器"><a href="#（2）专用寄存器" class="headerlink" title="（2）专用寄存器"></a>（2）专用寄存器</h4><p><strong>指令指针寄存器 IP （Instruction Pointer）</strong>保存下一次从主存中取出指令的偏移地址。</p><p><strong>标志寄存器 FR/PSW （Program Status Word）</strong> 含有<strong>状态标志</strong>和<strong>控制标志</strong></p><p>状态标志用来记录程序运行结果的状态信息，指令执行结束后会改变状态标志</p><div class="table-container"><table><thead><tr><th>标志名称</th><th>标志功能</th></tr></thead><tbody><tr><td>CF（Carry）进位标志</td><td>运算过程中有借位或进位时置 1，用于多字节运算、移位、比较大小</td></tr><tr><td>ZF（Zero）零标志</td><td>运算结果为 0 则置 0，反之置 1</td></tr><tr><td>SF（Sign）符号标志</td><td><strong>有符号数运算</strong>的结果若高位为 1 则置 1，反之置 0</td></tr><tr><td>PF（Parity）奇偶标志</td><td>运算结果<strong>最低8位</strong>中 1 的个数为偶数个时置 1，反之 0</td></tr><tr><td>OF（Overflow）溢出标志</td><td>若算数运算结果有溢出则置 1，反之 0（即算数运算结果是否正确）</td></tr></tbody></table></div><p>控制标志可用指令设定，用于控制处理器执行指令的方式</p><div class="table-container"><table><thead><tr><th>标志名称</th><th>标志功能</th></tr></thead><tbody><tr><td>DF（Direction）方向标志</td><td>串操作中控制地址变化方向，DF=0 时地址增加</td></tr><tr><td>IF（Interrupt-enable）中断允许标志</td><td>IF=1允许中断，否则禁止中断</td></tr><tr><td>TF（Trap Flag）陷阱标志</td><td>TF=1，处理器单步执行指令，产生编号为1的内部中断</td></tr></tbody></table></div><h4 id="（4）段寄存器"><a href="#（4）段寄存器" class="headerlink" title="（4）段寄存器"></a>（4）段寄存器</h4><p>有 SS、DS、CS、ES，略。</p><h2 id="三-访问内存"><a href="#三-访问内存" class="headerlink" title="三 访问内存"></a>三 访问内存</h2><p>8086/8088 的存储空间为 $2^{20}=1$MB，而其内部为16位寄存器，只能寻址 $2^{16}=64$KB，采用内存分段的方式来访问内存空间。</p><ol><li>8086/8088把1MB分成若干逻辑段，每个逻辑段最大为 64KB，可用 16 位地址表示。</li><li>设定段起始地址，段起始地址的格式为 0XXXX0H。某一段的开始必须使段起始地址。</li></ol><p>综上，使用逻辑段来划分存储空间，逻辑段的起始地址必须为段起始地址，而每一段的存储空间最大为 64KB，可以直接访问。因此，使用<strong>段起始地址+段内偏移地址（EA/Offset）</strong>的方式可以在16位寄存器的限制下访问到20位的<strong>物理地址（PA）</strong>。</p><p>物理地址计算公式</p><script type="math/tex; mode=display">PA=(SA<<4)+EA</script><p>其中 SA 为段地址。</p><blockquote><p>注意：内存访问存在<strong>内存对齐（memory alignment）</strong>的问题。8086的16位数据线每个内存周期依次读取偶单元和奇单元，每次一个字节。若字地址为偶单元，则1个内存周期即可读取，否则需要2个内存周期。若双字地址为偶单元，需要2个内存周期，否则需要3个。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1——寻址方式</title>
      <link href="2021/01/02/2-xun-zhi-fang-shi/"/>
      <url>2021/01/02/2-xun-zhi-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第二讲-寻址方式"><a href="#第二讲-寻址方式" class="headerlink" title="第二讲 寻址方式"></a>第二讲 寻址方式</h1><h2 id="一-操作数"><a href="#一-操作数" class="headerlink" title="一 操作数"></a>一 操作数</h2><p>操作数有三种来源，分别为<strong>立即数操作数</strong>、<strong>寄存器操作数</strong>和<strong>存储器操作数</strong>。指令通常格式为 <code>操作码 (操作数1，操作2)</code>，寻址的目的是获得指令操作数的地址。</p><h2 id="二-与数据有关的寻址方式"><a href="#二-与数据有关的寻址方式" class="headerlink" title="二 与数据有关的寻址方式"></a>二 与数据有关的寻址方式</h2><p>立即寻址和寄存器寻址无需访问存储器，运行速度较快。而后五种寻址方式需要访问存储器，其中相对寻址、基址变址寻址可以用来访问数组，而相对基址变址寻址可以用来访问二维数组。</p><div class="table-container"><table><thead><tr><th>寻址方式</th><th>操作数格式</th></tr></thead><tbody><tr><td>立即寻址方式</td><td>数字</td></tr><tr><td>寄存器寻址方式</td><td>通用寄存器和段寄存器</td></tr><tr><td>直接寻址</td><td>[buffer]（buffer为符号或数字）</td></tr><tr><td>间接寻址</td><td>[R]（之后以 R 来代指 BX/BP/SI/DI）</td></tr><tr><td>相对寻址</td><td>X[R] 或 [X+R]</td></tr><tr><td>基址变址寻址</td><td>[BX/BP+SI/DI]</td></tr><tr><td>相对基址变址寻址</td><td>R[BX/BP+SI/DI]</td></tr></tbody></table></div><blockquote><p>注：立即寻址中数字不能作为第一个操作数。操作数不能同时对存储器寻址。当操作数中出现 BP 时，默认段地址为 SS，此时 PA=(SS&lt;&lt;4) + Offset(buffer) ，这里的 buffer 表示存储器地址通式。否则 PA=(DS&lt;&lt;4) + Offset(buffer)</p></blockquote><ul><li><p>段跨越问题</p><p>  若不想使用默认的段地址，使用 <code>DS/SS/ES/CS:[buffer]</code> 的方式用来指定段地址。但是取指令操作、PUSH和POP操作、串处理指令的目的串不得使用段跨越前缀。</p></li></ul><h2 id="三-与转移地址有关的寻址方式"><a href="#三-与转移地址有关的寻址方式" class="headerlink" title="三 与转移地址有关的寻址方式"></a>三 与转移地址有关的寻址方式</h2><p>用来确定转移指令以及 <code>call</code> 指令的转向地址。转移指令负责将得到的段地址和偏移地址分别放入 CS 和 IP 寄存器中。</p><ul><li><p>段内转移</p><ul><li><p>段内直接寻址</p><ul><li>短转：JMP SHORT QUEST 8 位位移量，-128~+127</li><li>近转：JMP NEAR PTR NEXT 16 位位移量，-32768~32767</li></ul></li><li><p>段内间接寻址</p><ul><li>JMP R</li><li><p>JMP word ptr [buffer] 此处 buffer 同上，为存储器寻址方式统称</p><p>IP 寄存器中内容替换为访问存储单元内容</p></li></ul></li></ul></li><li><p>段间转移</p><ul><li><p>段间直接寻址</p><p>  JMP FAR PTR NEXTROUNT，其把 <code>seg nextrount</code> 放入 CS 中，<code>offset nextrount</code> 放入 IP 中</p></li><li><p>段间间接寻址</p><p>  JMP word ptr [buffer]，将存储器中高位放入 CS 中，低位放入 IP 中</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编复习简纲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习二</title>
      <link href="2020/12/29/wu-en-da-ji-qi-xue-xi-er/"/>
      <url>2020/12/29/wu-en-da-ji-qi-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习二"><a href="#吴恩达机器学习二" class="headerlink" title="吴恩达机器学习二"></a>吴恩达机器学习二</h1><blockquote><p>本章主要讲解的是利用逻辑回归求解分类问题，介绍了假设函数、决策边界、代价函数、梯度下降函数基本求解方法，随后介绍了使用更高级的优化策略来求解问题，并由二元分类推广至多元分类。然后引出了欠拟合和过拟合的问题，并引入了正则化的思想来解决该问题。</p></blockquote><h2 id="一、逻辑回归"><a href="#一、逻辑回归" class="headerlink" title="一、逻辑回归"></a>一、逻辑回归</h2><h3 id="1、分类问题"><a href="#1、分类问题" class="headerlink" title="1、分类问题"></a>1、分类问题</h3><p>分类问题中，对于给定输入 $x$，待预测的 $y$ 为离散值，在最简单的二元分类中  $y$ 的值仅取 1 或 0，通常称 $y=1$ 为正类，$y=0$ 为负类。例如给定肿瘤的大小、肿瘤发展的时间（向量 $x$），来判断肿瘤是否为恶性肿瘤（因变量 $y\in\{0,1\}$）。</p><p>如果使用线性回归算法的话，会带来两个问题：</p><ol><li>无法相对清晰的界定 $y$ 取不同值时 $x$ 所属的范围。</li><li>其输出值可能会远远超过 0 或 1，而我们仅仅需要预测 $y$ 为 0 或为 1.</li></ol><p>因此，我们采用逻辑回归算法（logistic regression）来求解分类问题。</p><h3 id="2、假设函数（Hypothesis-Representation）"><a href="#2、假设函数（Hypothesis-Representation）" class="headerlink" title="2、假设函数（Hypothesis Representation）"></a>2、假设函数（Hypothesis Representation）</h3><p>在线性回归中，我们的假设函数为（$x$ 和 $\theta$ 均为向量）：</p><script type="math/tex; mode=display">h_\theta(x)=x^T\theta</script><p>而逻辑回归中，我们的假设函数为：</p><script type="math/tex; mode=display">\begin{cases}h_\theta(x)=g(x^T\theta)\\g(t)=\frac{1}{1+e^{-t}}\end{cases}\Rightarrow h_\theta(x)=\frac{1}{1+e^{-x^T\theta}}</script><p>其中 $g(t)$ 为逻辑方程（logistic function），这也是逻辑回归名称的由来。其中 $g(x)$ 的图像如下所示：</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/image-20201228212739223.png" alt="逻辑函数图像" style="zoom: 33%;"></p><p>当 $h(x)\geq0.5$ 时，我们预测 $y=1$；当 $h(x)&lt;0.5$ 时，我们预测 $y=0$。其中 $h(x)$ 其实为 $y=1$ 的概率。有以下两组公式</p><script type="math/tex; mode=display">P(y=1|x,\theta)=h(x)\\P(y=0|x,\theta)=1-h(x)</script><p> 其表示在自变量 $x$ 以及参数为 $\theta$ 的条件下，$y=1$ 以及 $y=0$ 的概率。若我们通过数据集 ${X,y}$ 得到了优化后的参数 $\theta$ ，那么我们就可以写出假设函数 $h(x)$，进而输入 $x$ 来预测输出 $y$ 为 0 或者 $y$ 为 1 的概率。</p><h3 id="3、决策边界"><a href="#3、决策边界" class="headerlink" title="3、决策边界"></a>3、决策边界</h3><p>由假设函数可知</p><script type="math/tex; mode=display">y=1\Rightarrow h(x)\geq0.5\Rightarrow x^T\theta\geq0\\y=0\Rightarrow h(x)<0.5\Rightarrow x^T\theta<0</script><p>我们可以发现 $x^T\theta=0$ 定义了 $y=1$ 与 $y=0$ 的边界。例如 $x^T={1,x_1,x_2}$，我们输入训练数据之后得到 $\theta^T={\theta_0,\theta_1,\theta_2}$，那么由 $\theta_0+\theta_1x_1+\theta_2x_2=0$ 所决定的直线就定义了预测 $y=1$ 与 $y=0$ 的边界，我们称此边界为 <strong>决策边界</strong>。</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/image-20201228223857481.png" alt="决策边界实例" style="zoom: 33%;"></p><p>对于更复杂的决策边界，我们可以这样定义假设函数：</p><script type="math/tex; mode=display">h_\theta(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)\\h_\theta(x)=g(\sum_{k_1,k_2,\cdots,k_n}a_{k_1k_2\cdots k_n}x_1^{k_1}x_2^{k_2}\cdots x_n^{k_n})</script><p>从而得到更加复杂的边界曲线。</p><h3 id="4、代价函数"><a href="#4、代价函数" class="headerlink" title="4、代价函数"></a>4、代价函数</h3><p>我们需要根据代价函数来判断所选参数 $\theta$ 的优劣，并进一步通过梯度函数来优化参数 $\theta$ 。考虑在线性回归中选用的代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2</script><p>线性回归中，我们利用了其代价函数为凸函数的性质，进一步使用梯度下降法，得到梯度下降方程，从而可以不断地优化 $\theta$。而在分类问题中，若仍沿用线性回归中代价函数的处理办法，即定义</p><script type="math/tex; mode=display">J(\theta)_{logistic}=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2\\</script><p>即</p><script type="math/tex; mode=display">J(\theta)_{logistic}=\frac{1}{2m}\sum_{i=1}^m(g(x^T\theta))-y^{(i)})^2</script><p>那么我们得到的代价函数为非凸函数（non-convex function），无法应用梯度下降法。故重新定义梯度下降函数</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^mCost(h_\theta(x^{(i)}),y^{(i)})\\</script><p>其中</p><script type="math/tex; mode=display">Cost(h_\theta(x), y)=\begin{cases}-log(h_\theta(x))\quad &y=1\\-log(1-h_\theta(x))\quad &y=0\end{cases}</script><p>这样可以保证代价函数为凸函数，从而进一步应用梯度下降法。</p><h3 id="5、梯度下降法"><a href="#5、梯度下降法" class="headerlink" title="5、梯度下降法"></a>5、梯度下降法</h3><p>在应用梯度下降法之前，我们需要先将代价函数进行简化</p><script type="math/tex; mode=display">\begin{aligned}Cost(h_\theta(x),y)=&\begin{cases}-log(h_\theta(x))\quad &y=1\\-log(1-h_\theta(x))\quad &y=0\end{cases}\\&\Downarrow\\Cost(h_\theta(x),y)=&-(ylog(h\theta(x))+(1-y)log(1-h_\theta(x)))\end{aligned}</script><p>从而得到代价函数：</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\sum_{i=1}^m(ylog(h\theta(x))+(1-y)log(1-h_\theta(x)))</script><p>应用梯度下降方程并对 $J(\theta)$ 求导可得</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}</script><p><del>由于某种巧合</del>，可以发现该梯度下降方程和线性回归的梯度下降方程一样，但值得注意的是，两者的 $h_\theta(x)$ 函数并不相同。</p><h3 id="6、高级优化"><a href="#6、高级优化" class="headerlink" title="6、高级优化"></a>6、高级优化</h3><p>相较于上文的梯度下降方法，其实有更高级快速的方法可供选择。如 共轭梯度法（Conjugate descent）​、局部优化法（BFGS）、有限内存局部优化法（L-BFGS）。实现较为困难，可以直接掉包。（没错，我就是调包侠）</p><h3 id="7、多元分类问题"><a href="#7、多元分类问题" class="headerlink" title="7、多元分类问题"></a>7、多元分类问题</h3><p>有时我们会遇到因变量 $y$ 可以取不止两个值的情况，比如邮件分类可以分为垃圾邮件、家人邮件、公司邮件等，这时就需要对二元分类问题进行推广。</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/image-20201228234831484.png" alt="多元分类问题" style="zoom:33%;"></p><p>我们采用 One-vs-All 的思路来解决多元问题。令 $y=i$ 为正类，$y\neq i$ 为负类，那么我们可以得到关于 $y=i$ 的假设函数，有</p><script type="math/tex; mode=display">P(y=i|x,\theta)=h_\theta^{(i)}(x)</script><p>由此，对于 $n$ 元分类问题，我们可以得到 $n$ 个类似的假设函数，并通过数据集优化，得到这 $n$ 个假设函数各自的 $\theta$ 参数。我们称 $h_\theta^{(i)}$ 为 1 个分类机，可以得到 $n$ 个分类机。当我们进行预测时，我们将 $x$ 输入 $n$ 个分类机中，即通过 $h_\theta^{(i)}(x)$ 得到 $y=i$ 的概率，最后选择概率最大的 $i$ 输出即可。</p><p><img src="/2020/12/29/wu-en-da-ji-qi-xue-xi-er/image-20201229112923200.png" alt="多元分类问题求解" style="zoom:33%;"></p><h2 id="二、正则化"><a href="#二、正则化" class="headerlink" title="二、正则化"></a>二、正则化</h2><h3 id="1、拟合过程中的问题"><a href="#1、拟合过程中的问题" class="headerlink" title="1、拟合过程中的问题"></a>1、拟合过程中的问题</h3><p>在拟合过程中，会遇到<strong>欠拟合</strong>和<strong>过拟合</strong>的问题。</p><ul><li>欠拟合：拟合出来的曲线忽略了较多的信息，无法很好的满足数据特征</li><li>过拟合：拟合出来的曲线过于拟合训练数据，失去了预测性，难以满足数据的整体特征</li></ul><p>对于过拟合问题，有两个解决方法：</p><ul><li>丢弃多余的特征，即减少训练数据集中 $x$ 或 $\theta$ 的维度。或者使用可以自动选择模型的算法。</li><li>使用正则化的思想。保留所有 $\theta$ 参数，但减少其值。</li></ul><h3 id="2、正则化代价函数和梯度下降方程"><a href="#2、正则化代价函数和梯度下降方程" class="headerlink" title="2、正则化代价函数和梯度下降方程"></a>2、正则化代价函数和梯度下降方程</h3><p>我们通过向代价方程加入一个惩罚项，从而减小 $\theta$ 中某些维度上项的值，简化假设函数，解决假设函数过拟合的问题。</p><h4 id="（1）线性回归中的正则化"><a href="#（1）线性回归中的正则化" class="headerlink" title="（1）线性回归中的正则化"></a>（1）线性回归中的正则化</h4><p>定义正则化线性回归中代价函数为</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}(\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^n\theta_j^2)</script><p>其中 $\lambda\sum_{j=1}^n\theta_j^2$ 为惩罚项，用来防止出现某一个 $\theta$ 特别大导致出现过拟合的情况。当 $\lambda$ 设置过小时可能还是会导致过拟合，当其特别大时会导致欠拟合。按照约定俗成的习惯，我们并不对 $\theta_0$ 增加惩罚项。</p><p>进而得到梯度下降方程</p><script type="math/tex; mode=display">\begin{cases}\theta_0:=\theta_0-\frac{\alpha}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})\\\theta_j:=\theta_j-\alpha[\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j+\frac{\lambda}{m}\theta_j]\end{cases}</script><p>而如果使用正规方程来求解的话，我们可以得到：</p><script type="math/tex; mode=display">\theta=\Big(X^TX+\lambda\left[\begin{matrix}0 & 0 & \cdots & 0\\0 & 1 & \cdots & 0\\\vdots&\vdots&\ddots\\0 & 0 & \cdots & 1\end{matrix}\right]^{-1}\Big)X^Ty\theta=\Big(X^TX+\lambda\left[\begin{matrix}0 & 0 & \cdots & 0\\0 & 1 & \cdots & 0\\\vdots&\vdots&\ddots\\0 & 0 & \cdots & 1\end{matrix}\right]^{-1}\Big)X^Ty</script><h4 id="（2）逻辑回归中的正则化"><a href="#（2）逻辑回归中的正则化" class="headerlink" title="（2）逻辑回归中的正则化"></a>（2）逻辑回归中的正则化</h4><p>代价函数</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\sum_{i=1}^m[ylog(h\theta(x))+(1-y)log(1-h_\theta(x))]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2</script><p>梯度下降方程</p><script type="math/tex; mode=display">\begin{cases}\theta_0:=\theta_0-\frac{\alpha}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})\\\theta_j:=\theta_j-\alpha[\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x^{(i)}_j+\frac{\lambda}{m}\theta_j]\end{cases}</script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习一</title>
      <link href="2020/12/27/wu-en-da-ji-qi-xue-xi-yi/"/>
      <url>2020/12/27/wu-en-da-ji-qi-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="吴恩达机器学习（一）"><a href="#吴恩达机器学习（一）" class="headerlink" title="吴恩达机器学习（一）"></a>吴恩达机器学习（一）</h1><blockquote><p>主要总结了一下机器学习的基本知识，单变量线性回归的基本概念以及基本解法。</p></blockquote><h2 id="一、机器学习概括"><a href="#一、机器学习概括" class="headerlink" title="一、机器学习概括"></a>一、机器学习概括</h2><blockquote><p>定义：A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.——Tom Mitchell</p></blockquote><p>直白地来说，机器学习是一个被用来完成任务 $T$ 的程序，其可以通过在经验 $E$ 中学习，提高其任务完成的表现度 $P$。</p><ul><li><p>监管学习（supervised learning)</p><p>  有时候，我们希望通过给定程序特定的输入来进行预测。比如输入人口数目从而得到某一地区的销售额。<strong>监管学习</strong>是指首先给定程序已知的数据，随后期待给定未知的输入从而预测结果。比如首先给定已知的北京市人口与销售额的关系、上海市人口与销售额的关系等等，随后输入深圳市的人口，期待得到一个销售额的预测值。</p><p>  监管学习主要有<strong>回归分析</strong>（Regression）和<strong>分类分析</strong>（Classification）</p></li><li><p>无监管学习（unsupervised learning）</p><p>  有时候我们的数据没有标签，我们需要机器自动进行分类。比如一段声音中既有人声也有汽车声，采用无监管学习可以将人声和汽车声进行区分。</p></li></ul><h2 id="二、单变量线性回归基本概念"><a href="#二、单变量线性回归基本概念" class="headerlink" title="二、单变量线性回归基本概念"></a>二、单变量线性回归基本概念</h2><p>单变量线性回归属于监管学习。</p><p>给定一组数据，我们需要对该组数据进行线性拟合。如下图中，给定“人口-利润”的输入，随后我们找到一条直线，使得其尽可能反映数据集中“人口-利润”的线性关系。为此，首先需要定义函数：</p><p><img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/download.png" alt="人口-利润"></p><ul><li><p>假设函数（Hypothesis）</p><script type="math/tex; mode=display">  h_\theta=\theta_0+\theta_1x</script></li><li><p>参数（parameters）</p><script type="math/tex; mode=display">  \theta_0,\theta_1</script></li><li><p>代价函数（Cost Function）</p><script type="math/tex; mode=display">  J(\theta_0,\theta_1)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x_i)-y_i)^2</script></li></ul><p>我们的目标是得到使得代价函数 $J(\theta_0,\theta_1)$ 尽可能小的参数 $\theta_0,\theta_1$。</p><h2 id="三、单变量线性回归解决方法——梯度下降法"><a href="#三、单变量线性回归解决方法——梯度下降法" class="headerlink" title="三、单变量线性回归解决方法——梯度下降法"></a>三、单变量线性回归解决方法——梯度下降法</h2><p>我们通常采用梯度下降法（Gradient Descent）来解决线性回归问题。主要思路是，首先设置 $\theta_0,\theta_1$ 的初始值，随后不断改变 $\theta_0,\theta_1$，使得代价函数不断减小，直至收敛。我们采用下面的方程更新参数：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)\quad j\in\{0,1\}（1）</script><p>通过该方程，我们可以不断地逼近代价函数的极小值点，由于线性代价函数的极值点仅有一个，故其为最小值点，从而可以得到问题的解。其中 $\alpha$ 为逼近速率，当 $\alpha$ 过大时可能会造成不收敛的情况。</p><p>化简$（1）$式可得</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x_i)-y_i)x_j\quad j\in{0,1}</script><p>借助该式可以求解问题。</p><h2 id="四、多变量线性回归"><a href="#四、多变量线性回归" class="headerlink" title="四、多变量线性回归"></a>四、多变量线性回归</h2><p>训练数据包含多个特征值时需要用到多变量线性回归相关知识。比如房价会受到房子大小、房子卧室数目等因素的影响，则特征值包括房子大小、房子卧室等。给定多组训练数据，每组训练数据以 $\{x_1,x_2,…,x_n,y\}$ 的形式呈现。记 $X=(x_0,x_1,x_2,…,x_n)$，其中 $x_0\equiv1$，用来表征特征值。记 $\theta=(\theta_0,\theta_1,…,\theta_n)$ 用来表示参数。</p><p>多变量线性回归问题的假设函数为：</p><script type="math/tex; mode=display">h(x_1,x_2,...,x_n)=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_n+x_n</script><p>用向量形式表示即为：</p><script type="math/tex; mode=display">h(X)=X\cdot\theta^T</script><p>进而可以得到代价方程和梯度下降方程：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h(X^{(i)})-y^{(i)})^2\\\theta_j=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^m(h(X^{(i)})-y^{(i)})*X^{(i)}_j</script><p>其中 $X^{(i)}$ 表示第 $i$ 组测试数据的特征值向量，$X^{(i)}_j$ 表示第 $i$ 组测试数据的第 $j$ 个特征值，$y^{(i)}$ 表示第 $i$ 组测试数据的期望值。</p><h2 id="五、特征缩放"><a href="#五、特征缩放" class="headerlink" title="五、特征缩放"></a>五、特征缩放</h2><p>对于多变量线性回归，如果其特征值的大小相差较大，可能会出现迭代次数较多甚至不收敛的情况，这是就需要将数据放缩至同样的规模大小，放缩方法如下：</p><script type="math/tex; mode=display">X_j=\frac{X_j-Mean(X_j)}{Std(X_j)}</script><p>其中 $X_j$ 所有测试数据中第 $j$ 个特征值组成的向量，$Mean（）$ 表示求均值，$Std（）$ 表示求标准差。</p><h2 id="六、梯度下降图像方面的问题"><a href="#六、梯度下降图像方面的问题" class="headerlink" title="六、梯度下降图像方面的问题"></a>六、梯度下降图像方面的问题</h2><p>通常建议绘制“代价—迭代次数”图像，可以更方便的调试程序和优化程序。当代价并不随迭代次数的增加而减小时，通常情况下是因为选择的 $\alpha$ 过大，此时减小 $\alpha$ 即可。但同时 $\alpha$ 过小时也可能造成收敛较慢的问题，此时就需要根据图像选择较优的 $\alpha$</p><p>以下为作业题中“代价—迭代次数”图像的实例：</p><ul><li><p>当 $\alpha=1.315$ 时（不收敛）</p><p>  <img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/image-20201226174543644.png" alt="α=1.315" style="zoom: 33%;"></p></li><li><p>当 $\alpha=1$ 时（收敛较快）</p><p>  <img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/image-20201226174709353.png" alt="α=1" style="zoom:33%;"></p></li><li><p>当 $\alpha=0.001$ 时（收敛较慢）</p><p>  <img src="/2020/12/27/wu-en-da-ji-qi-xue-xi-yi/image-20201226174819646.png" alt="α=0.001" style="zoom:33%;"></p></li></ul><h2 id="七、使用正规方程求解"><a href="#七、使用正规方程求解" class="headerlink" title="七、使用正规方程求解"></a>七、使用正规方程求解</h2><p>对于形如</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h(X^{(i)})-y^{(i)})^2</script><p>的<strong>多元线性回归问题</strong>，存在使得 $J(\theta)’=0$ 的通解：</p><script type="math/tex; mode=display">\theta=(X^TX)^{-1}X^Ty</script><p>使用该方程可以直接求出最优拟合直线的参数。但是由于矩阵求逆的算法时间复杂度是 $O(n^3)$ 的，因此若数据组数较多时，该算法占用时间较大，仍需要使用迭代算法求解。</p><p><strong>通解求解过程</strong>：</p><script type="math/tex; mode=display">\begin{aligned}J(\theta)&=\frac{1}{2}(X\theta-y)^T(X\theta-y)\\&=\frac{1}{2}(\theta^TX^TX\theta-y^TX\theta-\theta^TX^Ty+y^Ty)\\\end{aligned}</script><p>根据矩阵求导法则有：</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial\theta^TX^TX\theta}{\partial\theta}&=2X^TX\theta\\\frac{\partial y^TX\theta}{\partial\theta}&=X^Ty\\\frac{\partial\theta^TX^Ty}{\partial\theta}&=X^Ty\end{aligned}</script><p>因此有：</p><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial\theta}=X^TX\theta-X^Ty</script><p>令导数等于零得：</p><script type="math/tex; mode=display">\begin{aligned}X^TX\theta-X^Ty&=0\\\theta&=(X^TX)^{-1}X^Ty\end{aligned}</script><p><del>矩阵求导法则有点多，我也没有搞太明白，就不在这里写了，以后可能会有补充 QAQ</del></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy数组学习</title>
      <link href="2020/12/24/numpy-shu-zu-xue-xi/"/>
      <url>2020/12/24/numpy-shu-zu-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy-数组学习"><a href="#numpy-数组学习" class="headerlink" title="numpy 数组学习"></a>numpy 数组学习</h1><p>2020.12.24 library jcy</p><p>这一部分主要包括 numpy 中关于数组的结构、定义以及相关操作</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h2><h2 id="1、创建一维序列"><a href="#1、创建一维序列" class="headerlink" title="1、创建一维序列"></a>1、创建一维序列</h2><p>可以将一维序列理解为数学中的向量</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建全 0 的序列</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment"># 创建全 1 的序列</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment"># 创建随机序列</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment"># 创建从 1-5 的序列</span>d <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token comment"># 创建 5 个等间距的样本</span>e <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token comment"># 创建自定义的序列</span>f <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[0. 0. 0. 0. 0.][1. 1. 1. 1. 1.][0.38560477 0.43756133 0.25563547 0.15480578 0.90388205][0 1 2 3 4][10.  12.5 15.  17.5 20. ][7 8 7 7 7]</code></pre><h2 id="二、创建二维数组"><a href="#二、创建二维数组" class="headerlink" title="二、创建二维数组"></a>二、创建二维数组</h2><p>可以将二维数组或更高维的数组理解为矩阵</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建一个 2*3 的全 0 矩阵</span>zero_2d_array <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'zero:\n'</span><span class="token punctuation">,</span> zero_2d_array<span class="token punctuation">)</span><span class="token comment"># 创建一个 2*3 的全 1 矩阵</span>one_2d_array <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'one:\n'</span><span class="token punctuation">,</span> one_2d_array<span class="token punctuation">)</span><span class="token comment"># 创建一个自定义矩阵</span>my_array <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'my:\n'</span><span class="token punctuation">,</span> my_array<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>zero: [[0. 0. 0.] [0. 0. 0.]]one: [[1. 1. 1.] [1. 1. 1.]]my: [[1 2] [3 4]]</code></pre><h2 id="三、多维数组的相关操作"><a href="#三、多维数组的相关操作" class="headerlink" title="三、多维数组的相关操作"></a>三、多维数组的相关操作</h2><h3 id="1、对多维数组进行切片"><a href="#1、对多维数组进行切片" class="headerlink" title="1、对多维数组进行切片"></a>1、对多维数组进行切片</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>              <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>6[[ 6  7] [10 11]][ 2  6 10 14][[ 1  3] [ 9 11]]</code></pre><h3 id="2、数组的属性"><a href="#2、数组的属性" class="headerlink" title="2、数组的属性"></a>2、数组的属性</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 类型名称</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>  <span class="token comment"># 内部的数据类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>size<span class="token punctuation">)</span>   <span class="token comment"># 数据数目</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># 数组的形状</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span>   <span class="token comment"># 每一项占用的字节数</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span>   <span class="token comment"># 数组的维度</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>nbytes<span class="token punctuation">)</span> <span class="token comment"># 数组中数据占用的字节数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;class &#39;numpy.ndarray&#39;&gt;int3216(4, 4)4264</code></pre><h2 id="四、使用数组进行运算"><a href="#四、使用数组进行运算" class="headerlink" title="四、使用数组进行运算"></a>四、使用数组进行运算</h2><h3 id="1、基本操作符"><a href="#1、基本操作符" class="headerlink" title="1、基本操作符"></a>1、基本操作符</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>a <span class="token operator">=</span> a<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">79</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span>              <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> b<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11] [12 13 14 15]][[10 62  1 14] [ 2 56 79  2] [ 1 45  4 92] [ 5 55 63 43]]</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 下方的 +、-、*、/、**、&lt;、> 都是对数组进行逐位运算</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span><span class="token comment"># 计算两个数组的点积</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[[ 10  63   3  17] [  6  61  85   9] [  9  54  14 103] [ 17  68  77  58]][[-10 -61   1 -11] [  2 -51 -73   5] [  7 -36   6 -81] [  7 -42 -49 -28]][[   0   62    2   42] [   8  280  474   14] [   8  405   40 1012] [  60  715  882  645]][[0.         0.01612903 2.         0.21428571] [2.         0.08928571 0.07594937 3.5       ] [8.         0.2        2.5        0.11956522] [2.4        0.23636364 0.22222222 0.34883721]][[  0   1   4   9] [ 16  25  36  49] [ 64  81 100 121] [144 169 196 225]][[ True  True False  True] [False  True  True False] [False  True False  True] [False  True  True  True]][[False False  True False] [ True False False  True] [ True False  True False] [ True False False False]][[  19  311  276  315] [  91 1183  864  919] [ 163 2055 1452 1523] [ 235 2927 2040 2127]]</code></pre><h3 id="2、特殊运算符"><a href="#2、特殊运算符" class="headerlink" title="2、特殊运算符"></a>2、特殊运算符</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>4509[ 0  1  3  6 10 15 21 28 36 45]</code></pre><h2 id="五、进阶索引方式"><a href="#五、进阶索引方式" class="headerlink" title="五、进阶索引方式"></a>五、进阶索引方式</h2><h3 id="1、花式索引"><a href="#1、花式索引" class="headerlink" title="1、花式索引"></a>1、花式索引</h3><p>花式索引可以通过给定的序列列表得到对应位置的元素，进而得到一个新的序列。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># fancy indexing</span><span class="token comment"># 给定一个索引列表得到对应的序列</span>a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>indices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>indices<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>[ 0 10 20 30 40 50 60 70 80 90][10 40 90]</code></pre><h3 id="2、bool-屏蔽"><a href="#2、bool-屏蔽" class="headerlink" title="2、bool 屏蔽"></a>2、bool 屏蔽</h3><p>bool 屏蔽可以通过一个 bool 型数组访问序列中的特定元素</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Bool Masking</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plta <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>pi<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment"># 得到函数图像</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token comment"># b >=0 返回一个 bool 型数组</span>mask <span class="token operator">=</span> b <span class="token operator">>=</span> <span class="token number">0</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>a<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'bo'</span><span class="token punctuation">)</span>mask <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;=</span> np<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>a<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'go'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/12/24/numpy-shu-zu-xue-xi/output_20_0.svg" alt="svg"></p><h3 id="3、where-函数"><a href="#3、where-函数" class="headerlink" title="3、where 函数"></a>3、where 函数</h3><p>where 函数用于得到满足指定条件的序列的下标。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>a <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">>=</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>(array([0, 1, 2, 3, 4], dtype=int64),)[5 6 7 8 9][False False False False False  True  True  True  True  True]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 重温</title>
      <link href="2020/12/23/python-chong-wen/"/>
      <url>2020/12/23/python-chong-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-重温"><a href="#Python-重温" class="headerlink" title="Python 重温"></a>Python 重温</h1><blockquote><p>高三暑假学习的 python，现在已经忘完了。由于机器学习和数学建模的需要，现在需要重拾一下 python 的相关知识，在这里粗略的总结一下其与 C 的不同之处以及基本语法。</p></blockquote><h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><ul><li>python 保留字</li></ul><div class="table-container"><table><thead><tr><th>python</th><th>保留</th><th>字符</th></tr></thead><tbody><tr><td>and</td><td>exec</td><td>not</td></tr><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table></div><ul><li>python 采用强制缩进，且缩进格式必须相同</li><li>可以使用 <code>\</code> 将一条语句分为多行</li><li>注释可以使用 <code>&quot;#&quot;</code> 或 <code>&#39;&#39;&#39;</code></li><li>使用 <code>;</code> 可以在一行显示多条语句</li></ul><h2 id="Python-变量类型"><a href="#Python-变量类型" class="headerlink" title="Python 变量类型"></a>Python 变量类型</h2><p>python 中有五种标准的变量类型分别为：数字、字符串、列表、元组、字典</p><ul><li>数字类型存在复数（complex）</li><li>对于序列（字符串、列表、元组）存在双向索引，可以利用索引取子串（或间隔取子串）。可以使用 <code>+</code> 和 <code>*</code> 进行运运算。对于列表、元组、字典，其可以互相嵌套。</li></ul><h2 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h2><ul><li>与 C 语言不同的是，Python 采用 <code>//</code> 进行实数除运算，采用 <code>//</code> 进行整除运算，采用 <code>**</code> 进行幂运算</li><li><code>is</code> 和 <code>is not</code> 运算符用来比较两个标识符是否引自一个对象，而 <code>==</code> 用于判断引用变量的值是否相等。<code>id()</code> 用于得到引用变量的地址，<code>is</code> 相当于利用该函数比较地址是否相同。</li></ul><h2 id="Python-中的数据类型转换函数"><a href="#Python-中的数据类型转换函数" class="headerlink" title="Python 中的数据类型转换函数"></a>Python 中的数据类型转换函数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x[,base])</td><td>将字符串或浮点数转换为整型</td></tr><tr><td>long(x[,base])</td><td>同上</td></tr><tr><td>float(x)</td><td>略</td></tr><tr><td>complex(real[,image])</td><td>略</td></tr><tr><td>str(x)</td><td>将对象转化为字符串类型</td></tr><tr><td>repr(x)</td><td>将对象 x 转化为表达式字符</td></tr><tr><td>eval(x)</td><td>将字符串转换为表达式并进行计算返回对象</td></tr><tr><td>tuple(s)、list(s)、set(s)、dict(d)、frozenset(s)</td><td>略</td></tr><tr><td>chr(x)、unichr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将字符转换为整数</td></tr><tr><td>hex(x)</td><td>将一个整数转化为十六进制字符串</td></tr><tr><td>oct(x)</td><td>将整数转化为八进制字符串</td></tr></tbody></table></div><h2 id="Python-中的数学函数"><a href="#Python-中的数学函数" class="headerlink" title="Python 中的数学函数"></a>Python 中的数学函数</h2><p>以下函数需调用 math 库</p><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>abs(x)、ceil(x)、cmp(x,y)、floor(x)、log10(x)、max(x1,x2,…)、min(x1,x2,…)、pow(x,y)、sqrt(x)</td><td>略</td></tr><tr><td>fabs(x)</td><td>返回绝对值的浮点数形式</td></tr><tr><td>log(x[,base])</td><td>返回以base为底的x的对数</td></tr><tr><td>modf(x)</td><td>返回 x 的整数和小数部分</td></tr><tr><td>round(x[,n])</td><td>返回 x 的四舍五入的值，n 表示小数点后的位数</td></tr><tr><td>acos()、asin()、atan()、cos()、sin()、tan()</td><td>略</td></tr><tr><td>atan2(y,x)</td><td>返回对应坐标的反正切值</td></tr><tr><td>hypot(x,y)</td><td>返回直角三角形的斜边</td></tr><tr><td>degrees(x)、radians(x)</td><td>将弧度转化为角度、将角度转化为弧度</td></tr><tr><td>pi、e</td><td>数学常量</td></tr></tbody></table></div><h2 id="Python-中的字符串"><a href="#Python-中的字符串" class="headerlink" title="Python 中的字符串"></a>Python 中的字符串</h2><ul><li>可以使用 <code>&#39;xxxx%s&#39;(&#39;hello&#39;)</code> 的形式格式化字符串</li><li>python 三引号可以保留字符串原有格式</li><li>可以使用 <code>u&#39;xxx&#39;</code> 的格式定义一个 Unicode 字符串</li><li><a href="[Python 字符串 | 菜鸟教程 (runoob.com">更多关于字符串的函数</a>](<a href="https://www.runoob.com/python/python-strings.html">https://www.runoob.com/python/python-strings.html</a>))</li></ul><h2 id="Python-中的列表"><a href="#Python-中的列表" class="headerlink" title="Python 中的列表"></a>Python 中的列表</h2><p>支持 <code>for in</code> 语句。</p><p>元组内置函数同列表内置函数相同。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">cmp</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token comment"># 比价两个列表</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment"># 得到列表长度</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token comment"># 将序列转化为列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">.</span>extend<span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token comment"># 拼接序列</span><span class="token builtin">list</span><span class="token punctuation">.</span>index<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment"># 找到第一个匹配项的位置</span><span class="token builtin">list</span><span class="token punctuation">.</span>insert<span class="token punctuation">(</span>index<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token comment"># 向序列中插入新对象</span><span class="token builtin">list</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">[</span>index<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 移除列表中的一个元素，并返回值</span><span class="token builtin">list</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment"># 移除列表中的第一个匹配项</span><span class="token builtin">list</span><span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 翻转列表</span><span class="token builtin">list</span><span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token builtin">cmp</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python-中的字典"><a href="#Python-中的字典" class="headerlink" title="Python 中的字典"></a>Python 中的字典</h2><p>可以使用 <code>del</code> 删除字典中的某一个键值对</p><p>字典键的特性：</p><ol><li>不允许同一个键出现两次。对于同一个键，首先出现的键会被覆盖。</li><li>键不允许改变，因此需要以数字、字符串或元组充当。</li><li>键对应的值可以为任意对象。</li></ol><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">dict</span><span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">dict</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 返回一个字典的浅拷贝</span><span class="token builtin">dict</span><span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span>seq<span class="token punctuation">[</span><span class="token punctuation">,</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 创建一个薪资点，以 seq 中的元素作为键，其对应的值为 val</span><span class="token builtin">dict</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token comment"># 返回 key 对应的值，若键不存在返回 default</span><span class="token builtin">dict</span><span class="token punctuation">.</span>has_key<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token comment"># 判断字典中是否存在 key 键</span><span class="token builtin">dict</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 返回一个列表，以元组形式表示所有键值对</span><span class="token builtin">dict</span><span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>key<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token comment"># 和 get 相似，但若不存在键则将添加键值对</span><span class="token builtin">dict</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>dict2<span class="token punctuation">)</span><span class="token comment"># 将 dict2 中内容并入 dict 中</span><span class="token builtin">dict</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token punctuation">,</span>default<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 删除并返回值</span><span class="token builtin">dict</span><span class="token punctuation">.</span>popitem<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 删除最后一对键值对</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python-中的函数"><a href="#Python-中的函数" class="headerlink" title="Python 中的函数"></a>Python 中的函数</h2><ul><li><p>参数传递</p><p>  在 python 中，类型属于对象，变量没有类型，可以将变量看做为一个指针，其可以指向任意数据类型，而其本身不属于任何类型。在 python 中，存在<strong>不可变类型</strong>，如数字、字符串、元组类型，也存在<strong>可变类型</strong>，如list、dict。在参数传递的过程中，不可变类型是<strong>值传递</strong>，而可变类型是<strong>引用传递</strong>。</p></li><li><p>参数列表</p><ul><li>必备参数：必须使用默认的参数顺序和参数数量</li><li>关键字参数：借用形参名称匹配传参，可以改变顺序</li><li>默认参数</li><li>不定长参数：在参数列表末尾追加元组指针<code>*var_args_tuple</code>即可。</li></ul></li><li><p>匿名函数（lambda函数）</p><p>  形如：<code>lambda [arg1[,arg2[,...]]]:expression</code> 返回表达式的值，其可以被赋值到一个变量中，该变量名即为函数名。</p></li></ul><h2 id="Python-文件-I-O"><a href="#Python-文件-I-O" class="headerlink" title="Python 文件 I/O"></a>Python 文件 I/O</h2><ul><li><p>打印：<code>print</code> 函数即可</p></li><li><p>读入：<code>input</code> ，返回读入的字符串</p></li><li><p>打开和关闭文件：使用 <code>open(file_name[,access_mode][,buffering]</code> 函数和 <code>close()</code> 方法。</p></li><li><p>file 文件的属性：<code>file.closed</code>、<code>file.mode</code>、<code>file.name</code>、<code>file.softspace</code></p></li><li><p>打开模式</p><p>  <img src="/2020/12/23/python-chong-wen/access-mode.png" alt="access mode"></p><p>  （图片引用自<a href="https://www.runoob.com/python/python-files-io.html">Python 文件I/O | 菜鸟教程 (runoob.com)</a>）</p></li><li><p>文件的写入：<code>write(str)</code> 方法</p></li><li><p>文件的读出：<code>read([count])</code> 方法，读取指定长度的字符串，否则读取整个文件。<code>readline([size])</code> 读取整行，<code>readlines([size])</code> 读取所有行并返回列表，<code>writelines(seq)</code>写入列表，需自己写入换行符。</p></li><li><p>文件定位：<code>tell</code> 方法告诉当前文件指针位置，<code>seek(offset[,from])</code> 方法用于重新定位指针位置</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论定理汇总(一)</title>
      <link href="2020/12/22/shu-lun-ding-li-hui-zong-yi/"/>
      <url>2020/12/22/shu-lun-ding-li-hui-zong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="数论定理汇总—一"><a href="#数论定理汇总—一" class="headerlink" title="数论定理汇总—一"></a>数论定理汇总—一</h1><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>已知两个数 $a$ 和 $b$，求 $gcd(a,b)$。</p><p>步骤：易证 $gcd(a,b)=gcd(b,a\bmod b)$，使用递归迭代求解直至 $b$ 为 0 时，$a$ 即为答案。</p><p>时间复杂度：$O(lgn)$</p><p>应用：可以求多个数的最大公因数。可以借助公式 $lcm(a,b)=\frac{a\cdot b}{gcd(a,b)}$ 求最小公倍数。</p><h3 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h3><p>用于求解 $ax+by=gcd(a,b)$ 的一组可行解。</p><p>步骤：构造方程组</p><script type="math/tex; mode=display">\begin{cases}ax_1+by_1=gcd(a,b)\\bx_2+(a\bmod b)y_2=gcd(b,a\bmod b)\end{cases}</script><p>解得</p><script type="math/tex; mode=display">\begin{cases}x_1=y_2\\y_1=x_2-\lfloor\frac{a}{b}\rfloor\end{cases}</script><p>依次关系构造递归函数求解即可。</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>欧拉函数 $\phi(n)$，表示的是小于等于 $n$ 且和 $n$ 互质的数的个数。</p><p>性质：</p><ul><li>欧拉函数是积性函数，当 $gcd(a,b)=1$ 时，满足 $\phi(a\times b)=\phi(a)\times\phi(b)$。</li><li>$n=\sum_{d|n}\phi(d)$</li><li>若 $n=p^k$，且 $p$ 为质数，则 $\phi(n)=p^k-p^{k-1}$</li><li>设 $n=\prod_{i=1}^np_i^{k_i}$，其中 $p_i$ 为质数，则有 $\phi(n)=n\cdot\prod_{i=1}^n\frac{p_i-1}{p_i}$</li></ul><p>应用：</p><p>欧拉定理：若 $gcd(a,b)=1$，则 $a^{\phi(b)}\equiv 1 (\bmod b)$</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃拉托斯特尼筛"><a href="#埃拉托斯特尼筛" class="headerlink" title="埃拉托斯特尼筛"></a>埃拉托斯特尼筛</h3><p>使用已求得素数的倍数筛去合数。</p><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><p>优化了埃氏筛以防止重复筛掉同一数字。</p><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>定义：若 $p$ 为素数，$gcd(a,p)=1$，则 $a^{p-1}\equiv1(\bmod p)$，或 $a^p\equiv a(\bmod p)$</p><ul><li><p>证明一：构造序列 $A=\{1,2,\cdots,p-1\}$，可得等式</p><script type="math/tex; mode=display">  \prod_{i=1}^{p-1}A_i=\prod_{i=1}^{p-1}A_i\cdot a\quad(\bmod p)\quad(1)</script><p>  下证该等式：</p><script type="math/tex; mode=display">  gcd(A_i\cdot a,p)=1\\  gcd(a,p)=1\\  A_i\cdot a\bmod p\neq A_j\cdot a\bmod p\quad(if\quad i\neq j)</script><p>  使用上述三个等式即可证明等式 $(1)$</p><p>  展开等式 $(1)$ 易得 $a^{p-1}\equiv1(\bmod p)$</p></li><li><p>证明二：使用数学归纳法+二项式定理证明</p><p>  显然</p><script type="math/tex; mode=display">  1^{p}\equiv 1\quad (\bmod p)</script><p>  假设当 $a\leq a$ 时 $a^p\equiv a(\bmod p)$ 成立，则由二项式定理</p><script type="math/tex; mode=display">  (a+1)^p=a^p+\binom{p}{1}a^{p-1}+\binom{p}{2}a^{p-1}+\cdots+1</script><p>  而对于 $\binom{p}{i}(i&lt;p)$ 其必然可以被 $p$ 整除，因此 $(a+1)^p \bmod p=a+1$，得证。</p></li></ul><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $gcd(a,b)=1$，则 $a^{\phi(b)}\equiv 1 (\bmod b)$</p><p>证明：其与费马小定理证明类似，唯一不同的是构造序列 $A$ 时，$A$ 需为模 $b$ 意义下的一个简化剩余系(简化剩余系为所有与 $b$ 互质的数组成集合的子集)。存在性质，若 $A$ 为 $b$ 的简化剩余系，则 $\{a\cdot A_i\}$ 也为 $b$ 的一个简化剩余系。</p><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>暂时用不到，就先把定理内容放在上边。</p><script type="math/tex; mode=display">a^b\equiv\begin{cases}a^{b\bmod \phi(p)},&gcd(a,p)=1\\a^b,&gcd(a,p)\neq1,b<\phi(p)\\a^{b\bmod \phi(p)+\phi(p)},&gcd(a,p)\neq1,b\geq \phi(p)\end{cases}\quad(\bmod p)</script><h2 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h2><p>使用 $O(lgn)$ 的时间复杂度求解形如</p><script type="math/tex; mode=display">f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor</script><ul><li><p>处理一：</p><p>  若 $a\geq c$ 或 $b \geq c$，可以使用整除理论对式子进行化简，化简结果如下：</p><script type="math/tex; mode=display">  f(a,b,c,n)=\lfloor\frac{a}{c}\rfloor\frac{n(n+1)}{2}+\frac{b}{c}n+f(a\bmod c,b\bmod c,c,n)</script></li><li><p>处理二：</p><script type="math/tex; mode=display">  \begin{aligned}  f(a,b,c,n)&=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\  &=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\  &=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum_{i=0}^n[j<\lfloor \frac{ai+b}{c}\rfloor]\\  &=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum_{i=0}^n[\lfloor\frac{jc+c-b-1}{a}\rfloor<i]\\  &=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}n-\lfloor\frac{jc+c-b-1}{a}\rfloor\\  &=n\cdot\lfloor\frac{an+b}{c}\rfloor-f(c,c-b-1,a,\lfloor\frac{an+b}{c}\rfloor-1)  \end{aligned}</script><p>  令 $m=\lfloor\frac{an+b}{c}\rfloor$，即有</p><script type="math/tex; mode=display">  f(a,b,c,n)=n\cdot m-f(c,c-b-1,a,m-1)</script><p>  使用欧几里得算法类似的思想进行迭代处理即可求解相应问题。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 欧几里得算法 </tag>
            
            <tag> 欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包九讲学习笔记</title>
      <link href="2020/12/18/bei-bao-jiu-jiang-xue-xi-bi-ji/"/>
      <url>2020/12/18/bei-bao-jiu-jiang-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="背包九讲学习笔记"><a href="#背包九讲学习笔记" class="headerlink" title="背包九讲学习笔记"></a>背包九讲学习笔记</h1><blockquote><p>“失败不是什么丢人的事情， 从失败中全无收获才是。”<br>                                                                                            ——崔添翼</p></blockquote><h2 id="1st-01背包问题"><a href="#1st-01背包问题" class="headerlink" title="1st_01背包问题"></a>1st_01背包问题</h2><p>$f[i][j]$ 表示前 $i$ 件物品在容量为 $j$ 的背包中所能获取到的最大价值。状态 $f[i][j]$ 是由<strong>先前状态+决策</strong>得到的，<strong>先前状态</strong>是指我们已知前 $i-1$ 件物品在容量为 $0-j$ 的背包中取值的最优解(即得到最大价值)，<strong>决策</strong>是指我们从前 $i-1$ 件物品的最优解到前 $i$ 件物品的最优解需要作出的选择。在这里，我们需要作出的选择有两种，一种是不将第 $i$ 件物品加入背包，一种是将第 $i$ 件物品加入背包，并从可选择的决策中选出最优的决策，其对应状态方程</p><script type="math/tex; mode=display">f[i][j]=max(f[i-1][j],f[i-1][j-c[i]])</script><p>若我们能够保证 $f[i-1][0…j]$ 是最优解，则我们由此得到的 $f[i][j]$ 必然也是最优解。<br>C++实现代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; c[i] 表示第 i 件物品所占用体积，w[i] 表示第 i 件物品的价值for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)        dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-c[i]]+w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2nd-完全背包问题"><a href="#2nd-完全背包问题" class="headerlink" title="2nd_完全背包问题"></a>2nd_完全背包问题</h2><p>与 <a href="#1_st01背包问题">01 背包问题</a> 的不同，在完全背包问题中，每一种物品都有无数个。沿用01背包状态<strong>先前状态+决策</strong>的思想，这里 $dp[i][j]$ 可以由若干决策得到，第 $k$ 个决策表示取 $k$ 个第 $i$ 种物品放入背包，我们要从这些决策中挑选出最优策略，只需添加一个循环语句即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)        for(int k &#x3D; 1; k &lt;&#x3D; j&#x2F;c[i]; ++k)            dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码时间复杂度为 $O(n^3)$，可以通过推导公式得到一个优化，考虑：</p><script type="math/tex; mode=display">\begin{aligned}dp[i][j] &= max(dp[i-1][j], dp[i-1][j-k\cdot c[i]] + k\cdot w[i]), k\in(1,\lfloor{\frac{j}{c[i]}}\rfloor)\\dp[i][j-c[i]] &= max(dp[i-1][j-c[i]], dp[i-1][j-c[i]-k\cdot c[i]] + k\cdot w[i]), k\in(1,\lfloor{\frac{j-w[i]}{c[i]}}\rfloor)\end{aligned}</script><p>可以发现</p><script type="math/tex; mode=display">\begin{aligned}&max(dp[i-1][j-k\cdot c[i]] + k\cdot w[i])(k\in(1,\lfloor{\frac{j}{c[i]}}\rfloor)\\=&max(dp[i-1][j-c[i]]+w[i], dp[i-1][j-(k+1)\cdot w[i]]+(k+1)\cdot w[i])(k\in(1,\lfloor{\frac{j}{c[i]}}\rfloor-1)\\=&max(dp[i-1][j-c[i]]+w[i], dp[i-1][j-c[i]-k\cdot c[i]] + k\cdot w[i] + w[i]), k\in(1,\lfloor{\frac{j-w[i]}{c[i]}}\rfloor)=&dp[i][j-c[i]]+w[i]\end{aligned}</script><p>因此得到<strong>优化公式</strong>：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*c[i]] + k*w[i]) = max(dp[i-1][j], dp[i][j-c[i]] + w[i])</script><p>故化简后的递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j], dp[i][j-c[i]] + w[i])</script><p>该公式表示 $max(dp[i-1][j-k\cdot c[i]]+k\cdot w[i])$ 与 $dp[i][j-c[i]] + w[i]$ 的值是相同的，因此可将上述代码中 $O(n^3)$ 的时间复杂度减少为 $O(n^2)$ 的时间复杂度。<br>上述是数学上的证明，也可以通过递归状态来理解<strong>优化公式</strong>。若前 $i$ 种物品可选，背包容量为 $j$，若想得到最优解，可以通过两种策略得到。一种是根本不选第 $i$ 种物品，则 $dp[i][j] = dp[i-1][j]$，另一种是选择第 $i$ 种物品，此时我们有最优状态 $dp[i][1…j-1]$(在这些状态中我们可能已经选择了第 $i$ 件物品)，可以基于此来得到若再次选择第 $i$ 件物品的价值 $dp[i][j] = dp[i][j-c[i]]$。由此思想也可以得到上述递推方程式。</p><p><strong>一个简单的优化</strong></p><p>在解决问题之前，有一个 $O(n^2)$ 的算法可以对其进行优化。即对所有物品进行两两比较，若存在 $c[i] &lt; c[j]$ 且 $w[i] &gt; w[j]$，则可以抛弃物品 $j$。</p><h2 id="3rd-多重背包问题"><a href="#3rd-多重背包问题" class="headerlink" title="3rd_多重背包问题"></a>3rd_多重背包问题</h2><h3 id="多重背包的-O-n-sum-logm-解法"><a href="#多重背包的-O-n-sum-logm-解法" class="headerlink" title="多重背包的 $O(n\sum logm)$ 解法"></a>多重背包的 $O(n\sum logm)$ 解法</h3><p>多重背包问题介于 01 背包问题和完全背包问题，其规定每一种物体最多可用 $M_i$ 个。考虑将其转化为 01 背包问题，则其相当于有 $\sum M_i$ 个物品的 01 背包问题(相当于将 1 种物品看做 $M_i$ 个不同的物品)。如果这样的话，则其时间复杂度为$O(n\cdot \sum M_i)$ ，时间复杂度较大，应考虑优化。</p><p>我们使用二进制的思想进行优化。考虑这样一个问题，对于数字 10，我们可以通过$a[1]\cdot 1+a[2]\cdot 1+…+a[10]\cdot 1$的方式取得$1-10$以内的所有值，其中$a[i]\in\{0,1\}$，我们也有另一种方式取到$1-10$以内的值，考虑$a[1]\cdot 1+a[2]\cdot 2+a[3]\cdot 2^2+a[4]\cdot (10-1-2-2^2)$，同样可以达到目标。使用相同的思想，对于第 $i$ 种物品，可以进行相关的划分，不再将其看成 $M_i$ 个独立的物品，而是将其划分成若干组，这些组中分别含有 $\{2^0,2^1,2^2,…2^{k-1},M_i-2^k+1\}$ 个第 $i$ 种物品，通过这些组的组合，我们可以得到范围内任意数量的第 $i$ 种物品，而我们将每一组看成一个独立的物品，其容量为 $m_k\cdot c[i]$ ，价值为 $m_k\cdot w[i]$，$m[1…k+1]=\{2^0,2^1,2^2,…2^{k-1},M_i-2^k+1\}$。</p><p>使用上述思想求解问题，问题的时间复杂度就降为$O(n\cdot \sum logm_i)$，大大降低了时间复杂度。貌似可以使用优先队列优化，但好像考题很少，此处略过~~~。</p><p>实现代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void OneZeroPack(int * dp, int n, int c, int w)&#123;    for(int i &#x3D; n; i &gt;&#x3D; c; --i)        dp[i] &#x3D; max(dp[i], dp[i-c]+w);&#125;void CompletePack(int * dp, int n, int c, int w)&#123;    for(int i &#x3D; c; i &lt;&#x3D; n; ++i)        dp[i] &#x3D; max(dp[i], dp[i-c]+w);&#125;&#x2F;&#x2F; m 表示该物品最多的个数void MultiplePack(int * dp, int n, int c, int w, int m)&#123;    if(c*m &gt;&#x3D; n)&#123;        &#x2F;&#x2F; 转化为完全背包问题        CompletePack(dp, n, c, w);        return;    &#125;    int k &#x3D; 1;    while(k &lt; m)&#123;        OneZeroPack(dp, n, k*c, k*w);        m -&#x3D; k;        k &lt;&lt;&#x3D; 1;    &#125;    OneZeroPack(dp, n, m*c, m*w);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多重背包可行性问题的-O-VN-解法"><a href="#多重背包可行性问题的-O-VN-解法" class="headerlink" title="多重背包可行性问题的 $O(VN)$ 解法"></a>多重背包可行性问题的 $O(VN)$ 解法</h3><p>若只考虑“每种有若干件的物品能否恰好填满背包”，而不考虑每一件物品的价值，那么有着 $O(N)$ 的算法。使用 $f[i][j]$ 表示 “使用前 $i$ 件物品恰好填满了容量为 $j$ 的背包后，最多还剩下第 $i$ 件物品的件数” ，若 $F[i][j]=-1$ 表示前 $i$ 件物品无法恰好填满容量为 $j$ 的背包。可以写出以下代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; m; ++i)    dp[i] &#x3D; -1;dp[0] &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    &#x2F;&#x2F; 从前 i-1 件物品转移到前 i 件物品    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)        dp[j] &#x3D; dp[j] &#x3D;&#x3D; -1 ? -1 : num[i];    &#x2F;&#x2F; 试图填满之前无法填满的背包    for(int j &#x3D; c[i]; j &lt;&#x3D; m; ++j)        &#x2F;&#x2F; 状态为 j 时是否使用第 i 件物品        if(dp[j-c[i]] &gt; 0)        dp[j] &#x3D; max(dp[j], dp[j-c[i]] - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4th-混合三种背包问题"><a href="#4th-混合三种背包问题" class="headerlink" title="4th_混合三种背包问题"></a>4th_混合三种背包问题</h2><p>如果在一个背包中，有的物体的个数有限、有的物体的个数仅有一个、有的物体的个数无限多个，这就是混合三种背包问题，对此，只需要将上述代码综合起来即可。伪代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    if 第 i 种物品有一个        ZeroOnePack(dp, m, c[i], w[i]);else if 第 i 种物品有无限个        CompletePack(dp, m, c[i], w[i]);else 第 i 种物品有 num 个        MultiplePack(dp, m, c[i], w[i], num);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5th-二维费用的背包问题"><a href="#5th-二维费用的背包问题" class="headerlink" title="5th_二维费用的背包问题"></a>5th_二维费用的背包问题</h2><p>二维费用的背包问题指对于每件物品有 $C$、$D$ 两种容量，同时对于这两种费用背包各有一个容量上限，在此基础上求背包所能达到的最大价值。</p><p>设 $f[i][u][v]$ 表示前 $i$ 件物品中背包的两种容量分别为 $u$ 和 $v$ 的情况下所能取得的最大价值，状态方程如下</p><script type="math/tex; mode=display">f[i][u][v]=max(f[i-1][u][v], f[i-1][u-C_i][v-D_i]+w[i])</script><p>给出伪代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)    for(int j &#x3D; s; j &gt;&#x3D; c[i]; --j)        for(int k &#x3D; t; k &gt;&#x3D; d[i]; --k)            f[j][k] &#x3D; max(dp[s][t], dp[s-c[i]][t-d[i]] + w[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6th-分组的背包问题"><a href="#6th-分组的背包问题" class="headerlink" title="6th_分组的背包问题"></a>6th_分组的背包问题</h2><p>有 $n$ 个物品，将其划分为 $k$ 组，每一组内部的物品最多选取一件，试求出该背包问题的最大解法。设 $dp[k][j]$ 表示前 $k$ 组在容量为 $j$ 的背包中的最大价值，其与 <a href="#1st_01背包问题">01背包</a> 的区别是：<strong>前者的决策是决定在第 $k$ 组中是否选出物品以及选出哪一个物品，后者是决定第 $i$ 件物品是否选中</strong>。递推方程如下：</p><script type="math/tex; mode=display">dp[k][j] = max(dp[k-1][j], dp[k-1][j-c[k][i]] + w[k][i] | i\in (1,num[k]))</script><p>其中 $c[k][i]$ 和 $w[k][i]$ 表示第 $k$ 组中第 $i$ 个物品的容量和价值，$num[k]$ 表示第 $k$ 组物品的数目。</p><p>给出代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int k &#x3D; 1; k &lt;&#x3D; K; ++k)    for(int j &#x3D; m; j &gt;&#x3D; 1; ++j)        for(int i &#x3D; 1; i &lt;&#x3D; num[k]; ++i)            if(j &gt;&#x3D; c[k][i])                dp[j] &#x3D; max(dp[j], dp[j-c[k][i]] + w[k][i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7th-有依赖的背包问题"><a href="#7th-有依赖的背包问题" class="headerlink" title="7th_有依赖的背包问题"></a>7th_有依赖的背包问题</h2><p>若选择了物品 $j$ ，则必须先选择物品 $i$，我们称物品 $j$ 依赖于物品 $i$。有依赖的背包问题指的就是当背包中的物品满足若干依赖关系式如何对该类问题进行求解。简化问题，我们仅假设依赖没有连续性，即不会出现 $A$ 依赖于 $B$，而 $B$ 依赖于 $C$ 的情况；又假设一件物品只能依赖于一件物品。</p><p>下面的话完全引用自崔添翼的背包九讲(但是我添加了部分锚点)，<del>—我实在无法找到更美妙的描述了—</del></p><blockquote><p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 $n$ 个附件，则策略有 $2^n + 1$ 个，为指数级。</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于<a href="#6th_分组的背包问题">分组背包</a>中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</p><p>再考虑对每组内的物品应用<a href="#2nd_完全背包问题">完全背包</a>中的优化。我们可以想到，对于第 $k$ 个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件 $k$ 的 “附件集合”先进行一次 01 背包，得到费用依次为 $0…V-C_k$ ，所有这些值时相应的最大价值 $F_k[0…V − C_k]$。那么，这个主件及它的附件集合相当于 $V − C_k + 1$ 个物品的物品组，其中费用为 $v$ 的物品的价值为 $F_k[v − C_k] + W_k$，$v$ 的取值范围是 $C_k ≤ v ≤ V$。</p><p>也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后， 将主件 $k$ 及其附件转化为 $V − C_k + 1$ 个物品的物品组，就可以直接应用<a href="#2nd_完全背包问题">完全背包</a>的算法解决问题了。</p></blockquote><p>实现代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 计算第 k 个物品组</span><span class="token comment">// 得到重量为 0~m-c[k][0]，价值为 f[k][0]~f[k][m-c[k][0]] 的物品</span><span class="token comment">// 这些物品代表同等重量中价值最高的物品组合</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token operator">-</span>c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>        f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> K<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m <span class="token operator">-</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> i <span class="token operator">-</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在考虑更加一般的情况。如果每个物品仍然只能依赖于一个物品，但是可以连续以来(不能循环依赖)，就构成了若干依赖树，那么该如何求解呢?可以采用相同的思路。仍然可以将一个主件即其附件集合看做一个物品组，但是由于其附件还有附件，因此需要先将其附件以及附件的附件看做一个物品组，以此类推。每当要求一个根节点的物品组时，先求得其子节点的物品组，这是一种树形动态规划的形式。</p><p>需要注意的是，我发现以上方法虽然通用但不代表是最优解。对组内进行朴素分组的时间复杂度为 $O(2^n)$，而通过上述方法进行分组的时间复杂度为 $O(k\cdot C)$，其中 $C$ 表示背包的容量。看似我们大大降低了时间复杂度，但是当面对 $n$ 较小而 $C$ 较大的情况时往往采用朴素分组的时间复杂度会更优。例子可以参考 <a href="https://www.luogu.com.cn/problem/P1064">金明的预算方案</a>。虽然如此，我认为上述方法对于思维的开拓是极其具有意义和价值的。</p><h2 id="8th-泛化物品"><a href="#8th-泛化物品" class="headerlink" title="8th_泛化物品"></a>8th_泛化物品</h2><p><strong>泛化物品</strong>是对背包内可装入的物品的一个更加抽象与广义的概念。其没有固定体积和价值，其价值随着被分配给它的体积而变化。即其价值与体积为一个函数关系，满足 $w=f(c)$，我们可称此方程为<strong>泛化函数</strong>。</p><p>对于一个容量为 $c$，价值为 $w$ 的物品，在 01 背包问题中其<strong>泛化函数</strong>为</p><script type="math/tex; mode=display">f(x)=\begin{cases}w,x=c\\0,x\neq c\end{cases}</script><p>在完全背包中其泛化函数为</p><script type="math/tex; mode=display">f(x)=\begin{cases}\frac{x}{c}*w,c\mid x\\0,c \nmid x\end{cases}</script><p>多重背包同理。</p><p>一个物品组也可以看做一个泛化物品。若物品组中存在容量为 $c$ 的物品，则 $f(c)$ 为所有容量为 $c$ 的物品中的最大价值，若不存在容量为 $c$ 的物品，则 $f(c)=0$。同样，对于<a href="#7th_有依赖的背包问题">依赖背包</a>问题，我们可以按照之前所述的两种方式对其进行分组，得到一个依赖分组中的泛化函数。</p><p>现在有两个泛化物品 $h$ 和 $l$ ，若给定他们以最大空间 $v$，通过分配 $h$ 和 $v$ 不同的空间，求得 $v$ 所能够得到的最大价值 $f(v)$，$f(v)$ 满足</p><script type="math/tex; mode=display">f(v) = max\{h(x) + l(v-x)|0\leq x\leq v\}</script><p>而通过 $v$ 的不同取值，我们可以得到一个新的泛化物品 $f$，其代表泛化物品 $h$ 和 $l$ 的和。此时以 $f$ 代替物品 $h$ 和 $l$，结果不会受到任何影响。</p><p>求解背包问题，就是不断地合并泛化物品并求解泛化物品最大值的过程，其通用形式如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 集合 S 表示一个泛化物品的集合for k in S    for v &lt;- C to 0        &#x2F;&#x2F; 合并泛化物品 obj 和 k，更新泛化物品 obj        obj[v] &lt;- max(obj[v - x] + k[x])return obj[C]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9th-背包问题的变化"><a href="#9th-背包问题的变化" class="headerlink" title="9th_背包问题的变化"></a>9th_背包问题的变化</h2><p>这里我会专门再写一篇博客来探究背包问题的不同问法，此处先留个坑。^ _ ^</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础图上问题小结</title>
      <link href="2020/12/18/ji-chu-tu-shang-wen-ti-xiao-jie/"/>
      <url>2020/12/18/ji-chu-tu-shang-wen-ti-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构图小结"><a href="#数据结构图小结" class="headerlink" title="数据结构图小结"></a>数据结构图小结</h1><blockquote><p>这篇小结中的所有题目均来自洛谷的”图的基本应用”题单。其中主要涉及到的相关知识有：dfs 和 bfs 的基本应用，根据 dfs 求有向无环图中最大路径、路径数量，根据拓扑排序判断图中是否有环的存在以及能否形成稳定的有序序列，找出图中的欧拉通路。</p></blockquote><p>[TOC]</p><h2 id="P5318-查找文献（dfs和bfs基本应用）"><a href="#P5318-查找文献（dfs和bfs基本应用）" class="headerlink" title="P5318_查找文献（dfs和bfs基本应用）"></a>P5318_查找文献（dfs和bfs基本应用）</h2><ul><li><p><a href="https://www.luogu.com.cn/problem/P5318">题目连接</a></p></li><li><p>题目描述：给定一个有向图，输出深搜和广搜的结果，但是必须保证输出结果的字典序尽可能的小</p></li><li><p>解题思路：<br>  该题的难点在保证输出字典序尽可能小，因此需要对每一个点的邻接点按照序号进行排序，随后 dfs、bfs 即可</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; q 是用于存储邻接表的 vector 数组for(int i &#x3D; 0; i &lt; m; ++i)&#123;    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    q[a].push_back(b);&#125;for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    sort(q[i].begin(), q[i].end());&#125;&#x2F;&#x2F; 随后根据排序后的邻接表深搜和广搜即可dfs();bfs();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P3916-图的遍历（dfs查找到达的最大顶点）"><a href="#P3916-图的遍历（dfs查找到达的最大顶点）" class="headerlink" title="P3916_图的遍历（dfs查找到达的最大顶点）"></a>P3916_图的遍历（dfs查找到达的最大顶点）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P3916">题目链接</a></p></li><li><p>题目描述：给定一个有向图，有 n 个点， m 条边，其中点从 1 到 n 进行编号。确定每个点所能到达的最大点的编号</p></li><li><p>解题思路：<br>  这道题本质是一个深度优先搜索，对每一个点进行搜索即可。但是关键的一点是从第 n 个点开始搜索，第 n 个点所到达的点的最大值必然是 n，同时将其进行标记；随后从第 n-1 个点开始搜索，对于所有未被访问过的点来说，如果其能被第 n-1 个点到达，那么其可到达的最大值必然是 n-1，以此类推，直到第 1 个点为止。</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int p, int v)&#123;    a[p] &#x3D; v;   &#x2F;&#x2F; 记录点 p 可以到达的编号最大的点    vis[p] &#x3D; true;    for(int k &#x3D; head[p]; k; k &#x3D; edges[k].next)&#123; &#x2F;&#x2F; 继续寻找点 v 可以到达的点        if(!vis[edges[k].to])            dfs(edges[k].to, v);    &#125;&#125;&#x2F;&#x2F; 从第 n 个点开始倒序搜索for(int i &#x3D; n; i &gt;&#x3D; 1; --i)&#123;    if(!vis[i]) dfs(i, i);  &#x2F;&#x2F; 若点 i 已经被访问，则点 i 可以到达的顶点也一定已经被访问了                            &#x2F;&#x2F; 此时无需 dfs&#125;&#x2F;&#x2F; 输出结果for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    printf(&quot;%d &quot;, a[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1113-杂务（dfs查找固定终点的最长路径）"><a href="#P1113-杂务（dfs查找固定终点的最长路径）" class="headerlink" title="P1113_杂务（dfs查找固定终点的最长路径）"></a>P1113_杂务（dfs查找固定终点的最长路径）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1113">题目链接</a></p></li><li><p>题目描述：John 在给奶牛挤奶前需要完成许多杂务，只有一些杂务已经被完成之后某些杂物才能开始去做。例如，如果想要完成杂务<code>D</code>，而杂务<code>D</code>需要在<code>A</code>、<code>B</code>都已经完成的情况下才能开始做。完成每个杂务都需要一定的时间，而农场中有足够的工人去同时去做没有依赖关系的杂务，求完成所有杂务所需的最短时间。</p></li><li><p>解题思路：<br>  使用深搜的思想来解决拓扑排序的问题。假设杂务<code>D</code>需要<code>A</code>、<code>B</code>都完成后才能开始，设 <code>t[D]</code> 为完成杂务D所需的最短时间，则 <code>t[D] = min(t[A], t[B])</code>，而完成A，B所需的最短时间以此类推，直到没有前一项杂务为止。</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v[maxn];int dfs(int p)&#123;    int len &#x3D; v[p].size();    int mx &#x3D; 0;    for(int i &#x3D; 0; i &lt; len; ++i)&#123;        &#x2F;&#x2F; 使用记忆化搜索可以极大的减少时间        if(!vis[v[p][i]]) mx &#x3D; max(dfs(v[p][i]), mx);        else mx &#x3D; max(vis[v[p][i]], mx);    &#125;    vis[p] &#x3D; mx + t[p]; &#x2F;&#x2F; 记录完成杂务 p 所需时间    return vis[p];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>相似题型：<a href="https://www.luogu.com.cn/problem/P4017">P4017最大食物链计数</a>该题求一个有向无环图中从头至尾链的数目，用的同样是 dfs 的思想来解决拓扑排序的问题。</li></ul><h2 id="P1807-最长路（dfs查找固定起点和终点的最长路径）"><a href="#P1807-最长路（dfs查找固定起点和终点的最长路径）" class="headerlink" title="P1807_最长路（dfs查找固定起点和终点的最长路径）"></a>P1807_最长路（dfs查找固定起点和终点的最长路径）</h2><ul><li><p><a href="https://www.luogu.com.cn/problem/P1807">题目链接</a></p></li><li><p>题目描述：给定一个有向无环图，有 n 个顶点 m 条边，顶点从 1 至 n 进行编号，边有权值，可以为负权。求出从点 1 到点 n 的最大路径，若不连通则输出-1。</p></li><li><p>解题思路：同样的深搜。其与上一题的区别在于对递归边界返回值的处理。</p></li><li><p>核心代码</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 返回点 p 到达 1 的最长距离int dfs(int p)&#123;    if(p &#x3D;&#x3D; 1) return 0;    int mx &#x3D; -INF, v;    vis[p] &#x3D; true;    for(int k &#x3D; head[p]; k; k &#x3D; edges[k].nxt)&#123;        v &#x3D; edges[k].v;        if(!vis[v]) dfs(v); &#x2F;&#x2F; 递归的求解点 p 到点 1 的最长距离        &#x2F;&#x2F; 如果联通，则找到最大的子路径        if(len[v] !&#x3D; INF) mx &#x3D; max(mx, len[v] + edges[k].w);    &#125;    if(mx &#x3D;&#x3D; -INF) mx &#x3D; INF;    return len[p] &#x3D; mx;&#125;&#x2F;&#x2F; 随后从点 n 开始 dfs 即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1127-词链（求欧拉通路）"><a href="#P1127-词链（求欧拉通路）" class="headerlink" title="P1127_词链（求欧拉通路）"></a>P1127_词链（求欧拉通路）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1127">题目链接</a></p></li><li><p>题目描述：如果单词 x 的尾字母和单词 y 的首字母相同，则单词 x 可以和单词 y 首尾相连成词链 x.y。现给定一些单词，找出字典序最小的词链，并且所有单词在该词链中出现并且只出现一次。</p></li><li><p>基础知识：该题是一道求<strong>欧拉通路</strong>的题。由于我离散数学学的不是很好，因此还不得不百度了一下如何求欧拉通路QAQ。因此需要明确一些欧拉通路的概念。</p><ul><li><strong>欧拉通路</strong>：通过图中的每条边且仅通过一次，并且通过每一个顶点的路径</li><li><strong>欧拉回路</strong>：通过图中的每条边且仅通过一次，并且通过每一个顶点的回路</li><li><strong>判断欧拉通路是否存在</strong>：对于无向图，该图必须联通，有且仅有两个顶点的度数为奇数，其余顶点的度数为偶数，且该两个顶点为欧拉通路的两端；对于有向图，该有向图的基图需联通（将所有有向边变为无向边），有且仅有两个顶点的出度和入度不相等，且一个顶点的出度比入读大 1（通路起点），一个顶点的入读比出度大 1（通路终点），其他所有顶点出度和入度相同。</li><li><strong>判断欧拉回路是否存在</strong>：对于无向图，其所有顶点的度数都为偶数；对于有向图，其所有顶点的出度和入读相同。<br>  <img src="/2020/12/18/ji-chu-tu-shang-wen-ti-xiao-jie/Euler.PNG" alt="euler_step"></li><li><strong>求解欧拉通路/回路的步骤</strong>：<ul><li>注：此处仅以<strong>有向图的欧拉通路</strong>为例，并且假设通路起点入读为 0，出度为 1，终点出度为 0，入读为 1。在我们的遍历过程中，我们每从一个顶点出发，该顶点的出度 -1，每进入一个顶点，该顶点的入读 -1。</li><li><strong>step1</strong>：首先我们可以轻易的<strong>确定欧拉通路的开始顶点</strong>，如上图所示，开始顶点为 <code>A</code>，随后我们以 <code>A</code> 为起点开始dfs。如 <code>step1</code>，假设我们访问到了顶点 <code>H</code>，若 <code>H</code> 非回路终点，那么由于<strong>出度与入读相同</strong>，则其必有一条边可以使我们继续向下访问，接下来我们访问到点 <code>I</code>，若 <code>I</code> 同样不是通路终点，则我们同样一定可以继续走下去。</li><li><strong>step2</strong>：我们将如同step1中所示持续向下访问，直到我们到达<strong>通路终点</strong> <code>Z</code>，由于其出度为 0，我们无法继续向下访问，此时我们可以得到一条路径<code>&quot;A-&gt;H-&gt;I-&gt;Y-&gt;Z&quot;</code>，通常情况下此条路径无法遍历有向图中所有的顶点，因此我们需要继续拓展到其他的点。</li><li><strong>step3</strong>：我们访问完 <code>Z</code> 之后，开始<strong>回退</strong>，回到上一次的顶点 <code>Y</code>，若 <code>Y</code> 的边已经被遍历完毕，则我们继续回退，回到顶点 <code>I</code>，此时我们发现 <code>I</code> 有其他的边，这是我们开始以 <code>I</code> 为起点进行 dfs，当从 <code>I</code> 出发时，此时 <code>I</code> 的入读比出度大 1。同样的，由于从 <code>I</code> 点开始 dfs 所访问到的顶点的出度与入读相同，因此 dfs 最终将只能在入读比出度小 1 的顶点（即点 <code>I</code>）终止。我们可得到一条回路 <code>&quot;I-&gt;N-&gt;M-&gt;I&quot;</code></li><li><strong>step4</strong>：深搜完点 <code>I</code> 之后，我们将回退点 <code>N、M</code>，若 <code>N、M</code> 没有多余边，则继续回退，此时回退到点 <code>H</code>，依照步骤4，我们访问到了 <code>G</code> 点并回到 <code>H</code></li><li><strong>step5</strong>：在 <code>step4</code> 中，当我们回到 <code>G</code> 后，需要对从 <code>G</code> 点出发深搜到的点进行回退，假设我们回退到点 <code>G</code>，发现点 <code>G</code> 仍有其他边，则从 <code>G</code> 出发开始深搜，搜到了 <code>D</code> 和 <code>E</code>，随后结束搜索。若此时图中的所有边都已经被遍历，则我们将持续回退，直到回退到点 <code>A</code>，结束欧拉通路的查找。</li><li>如果我们在某一节点回退结束时输出当前节点，则最后我们可以得到序列 <code>&quot;Z Y I M N I H G D E G H A&quot;</code></li></ul></li><li><p>具体查找欧拉通路的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 使用邻接矩阵进行dfs得到欧拉回路，实际操作中建议使用前向星或邻接表&#x2F;&#x2F; 此处给出无向图查找欧拉通路，有向图可以自己写写试试看int graph[maxn][maxn];int path[maxn], cnt &#x3D; 0, vis[maxn];int n, m;void dfs(int p)&#123;    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;    &#x2F;&#x2F; 遍历顶点 p 的所有邻接点        if(graph[p][i])&#123;            --graph[p][i];  &#x2F;&#x2F; 减去顶点的度数            --graph[i][p];            dfs(i);        &#125;    &#125;    path[cnt++] &#x3D; p;    &#x2F;&#x2F; 遍历完点 p 的所有邻接边之后存储点 p&#125;int main()&#123;    int u, v;    cin&gt;&gt;n&gt;&gt;m;    for(int i &#x3D; 0; i &lt; m; ++i)&#123;        scanf(&quot;%d %d&quot;, &amp;u, &amp;v);        ++graph[u][v];        ++graph[v][u];    &#125;    dfs(1);    &#x2F;&#x2F; 最终输出结果为倒序    for(int i &#x3D; 0; i &lt; cnt; ++i)&#123;        cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>核心代码：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int u)&#123;    for(int p &#x3D; head[u]; p; p &#x3D; edges[p].nxt)&#123;        if(!edges[p].vis)&#123;            edges[p].vis &#x3D; 1;            dfs(edges[p].v);            path.push(edges[p].word);        &#125;    &#125;&#125;int main()&#123;    input();    &#x2F;&#x2F; 读入单词，并进行建图，由于要求字典序最小，因此需要进行排序，参考上文 图的遍历 一题    int flag &#x3D; -1;    &#x2F;&#x2F; 找到起点 flag    for(int i &#x3D; 0; i &lt; maxgroup; ++i)&#123;        &#x2F;&#x2F; degree[i][0] 表示出读，degree[i][1] 表示入度        if(degree[i][0] &#x3D;&#x3D; degree[i][1]+1)&#123;            flag &#x3D; i;            break;        &#125;    &#125;    if(flag &#x3D;&#x3D; -1)&#123;        &#x2F;&#x2F; 如果找不到起点，说明此时存在欧拉回路，只需找到字典序最小的单词即可        for(int i &#x3D; 0; i &lt; maxgroup; ++i)&#123;            if(words[i].size())&#123;                dfs(i);                break;            &#125;        &#125;    &#125;    else dfs(flag); &#x2F;&#x2F; 从起点开始 dfs    output();    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1363-幻象迷宫（dfs思维题）"><a href="#P1363-幻象迷宫（dfs思维题）" class="headerlink" title="P1363_幻象迷宫（dfs思维题）"></a>P1363_幻象迷宫（dfs思维题）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1363">题目链接</a></p></li><li><p>题目描述：给定一个n*m的矩阵迷宫，其中“#”表示墙，“.”表示道路，将该迷宫上下左右进行平移，可以平铺成一个无限大的迷宫。给定起点，问能否从起点出发到达无限远的位置。</p></li><li><p>解题思路：进行dfs搜索，记录走到的位置的<strong>绝对位置</strong>（lx, ly)（绝对位置是指其在无限大迷宫中相对起点的横纵坐标，也就是说lx,ly不对边长进行取模运算），同时该所走到的位置还有一个<strong>朴素位置</strong>（x，y）（朴素位置是指其在原始迷宫中相对起点的位置，x,y需进行取模运算）。当走到某个位置时，若之前已经走到过该位置，且两次的绝对位置不同，则可以在迷宫中可以走到无限远的地方。</p></li><li><p>核心代码：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; x，y表示朴素位置，lx，ly表示绝对位置&#x2F;&#x2F; g[x][y][0] 记录该点是否已访问以及能否访问，-1 表示该点为墙，0 表示未访问，1 表示已被访问过&#x2F;&#x2F; g[x][y][1] 和 g[x][y][2] 分别记录绝对位置的横纵坐标bool dfs(int x, int y, int lx, int ly)&#123;    bool flag &#x3D; false;    if(g[x][y][0]&#x3D;&#x3D;1 &amp;&amp; (g[x][y][1]!&#x3D;lx || g[x][y][2]!&#x3D;ly))&#123;        &#x2F;&#x2F; 当前位置之前已经访问过，且两者的绝对位置不同        flag &#x3D; true;    &#125;else if(g[x][y][0]&#x3D;&#x3D;0)&#123;        &#x2F;&#x2F; 进行标记记录绝对位置        g[x][y][0] &#x3D; 1;        g[x][y][1] &#x3D; lx;        g[x][y][2] &#x3D; ly;        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;            int xx &#x3D; (x + d[i].x + n)%n;            int yy &#x3D; (y + d[i].y + m)%m;            flag &#x3D; dfs(xx, yy, lx+d[i].x, ly+d[i].y);            if(flag) break;        &#125;    &#125;    return flag;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1347-排序（拓扑排序确定有序序列）"><a href="#P1347-排序（拓扑排序确定有序序列）" class="headerlink" title="P1347_排序（拓扑排序确定有序序列）"></a>P1347_排序（拓扑排序确定有序序列）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1347">题目链接</a></p></li><li><p>题目描述：有一串字母，两两之间满足大小关系，现给定 n 个字母，m 条关系，每条关系以 “A &lt; B” 的形式依次给出，若根据前 x 条关系可以确定这 n 个字母唯一的顺序关系，则输出结果，若根据前 x 条关系发现这 n 个字母之间无法形成顺序关系，同样输出结果，若直到最后也无法确定其是否能够组成固定的顺序关系，则输出另一结果。</p></li><li><p>解题思路：这道题是一道典型的拓扑排序题目，每读入一个关系，就根据当前所建图执行一遍拓扑排序，其有三种结果：发现当前图成环、发现可以确定唯一的顺序关系、发现无法确定唯一的顺序关系。前两种结果直接输出，停止程序，而若是第三种结果则继续读入，重复拓扑排序的步骤。</p></li><li><p>核心代码：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int topo()&#123;    queue&lt;int&gt; q;    int flag &#x3D; 0, degree[maxn], cnt &#x3D; 0;    &#x2F;&#x2F; 复制一遍顶点入度    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        degree[i] &#x3D; indegree[i];    &#125;    &#x2F;&#x2F; 将所有入度为 0 的点加入队列    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        if(!degree[i])&#123;            q.push(i);        &#125;    &#125;    &#x2F;&#x2F; 开始拓扑排序    int p;    while(!q.empty())&#123;        &#x2F;&#x2F; 当队列中存在不止一个元素时，说明此时存在不稳定的队列或者当前的边未包括全部的顶点        if(q.size() &gt; 1) flag &#x3D; 1;        p &#x3D; q.front(); q.pop();        ans[cnt++] &#x3D; p; &#x2F;&#x2F; 记录当前确定的顺序，该顺序可能唯一，也可能不唯一        for(int k &#x3D; head[p]; k; k &#x3D; edges[k].nxt)&#123;            int pp &#x3D; edges[k].to;            --degree[pp];            if(!degree[pp]) q.push(pp);        &#125;    &#125;    &#x2F;&#x2F; 通过检查是否有入度不为0来确定是否存在环    int status &#x3D; 0;     &#x2F;&#x2F; 默认既没有环，也没有稳定序列    for(int i &#x3D; 0; i &lt; n; ++i)&#123;        if(degree[i])&#123;            status &#x3D; 1; &#x2F;&#x2F; 标记存在环            break;        &#125;    &#125;    if(!flag &amp;&amp; !status &amp;&amp; cnt &#x3D;&#x3D; n) status &#x3D; 2;   &#x2F;&#x2F; 此时存在稳定序列    return status;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="P1983-车站分级（有向无环图不固定起点和终点最长路径）"><a href="#P1983-车站分级（有向无环图不固定起点和终点最长路径）" class="headerlink" title="P1983_车站分级（有向无环图不固定起点和终点最长路径）"></a>P1983_车站分级（有向无环图不固定起点和终点最长路径）</h2></li><li><p><a href="https://www.luogu.com.cn/problem/P1983">题目链接</a></p></li><li><p>题目描述：有编号从 1 到 n 的火车站，不同的站点有不同的登记。火车会在其经过的某些火车站停下，如果火车站在序列为{$a_1,a_2,a_3,…,a_k$}的车站中停下，则从首发站 $a_1$ 到终点站 $a_k$ 中的所有<strong>没有停下的车站</strong>的级别都低于停下的车站{$a_1,a_2,a_3,…,a_k$}。现给出 m 个火车的航站表（每个表中包含了第 i 趟火车所有停下的车站），试确定所划分级别的最小数目。</p></li><li><p>解题思路：首先根据航站表建图，根据已确定的等级关系所建的图找出图中最长路径即可。详情见题目<a href="P1113_杂务（dfs查找固定终点的最长路径）">杂务</a>。本题的一个小难点在于如何根据航展表建图，建图部分代码如下：</p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; bool vis[maxn] 记录停下的站点&#x2F;&#x2F; bool g[maxn][maxn] 记录已经加的边void input()&#123;    n &#x3D; read(); m &#x3D; read();    int port[maxn]; &#x2F;&#x2F; 记录停下的站点    for(int i &#x3D; 0; i &lt; m; ++i)&#123;        int k, l, r;        k &#x3D; read();        memset(vis, 0, sizeof(vis));        for(int j &#x3D; 0; j &lt; k; ++j)&#123;            port[j] &#x3D; read();   &#x2F;&#x2F; 以两种方式存储停下的站点            vis[port[j]] &#x3D; 1;        &#125;        l &#x3D; port[0]; r &#x3D; port[k-1]; &#x2F;&#x2F; 得到始发站和终点站        for(int p &#x3D; l; p &lt; r; ++p)&#123; &#x2F;&#x2F; 遍历是发展到终点站之间的所有站点            if(!vis[p])&#123;    &#x2F;&#x2F; 如果该站点未被停下，则为该站点和停下的站点建边                for(int j &#x3D; 0; j &lt; k; ++j)&#123;                    if(!g[port[j]][p])&#123; &#x2F;&#x2F; 若该边已经加过，则不再添加                        edges[port[j]].push_back(p);                        g[port[j]][p] &#x3D; true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数学问题小结</title>
      <link href="2020/12/18/ji-chu-shu-xue-wen-ti-xiao-jie/"/>
      <url>2020/12/18/ji-chu-shu-xue-wen-ti-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="基础数学问题总结"><a href="#基础数学问题总结" class="headerlink" title="基础数学问题总结"></a>基础数学问题总结</h1><blockquote><p>基础数学问题主要涉及到进制的转换、位运算、计数原理与排列组合和整除理论。注：本题解中代码未必为 AC 代码, 因为其为了配合题目知识点的理解进行了一部分简化。</p></blockquote><h2 id="进制的转换以及位运算"><a href="#进制的转换以及位运算" class="headerlink" title="进制的转换以及位运算"></a>进制的转换以及位运算</h2><blockquote><p>进制的转换要求能够熟练的进行不同进制之间的转换，二进制、八进制、十六进制和十进制都是非常常见的进制表达形式。</p></blockquote><ul><li><p><strong>题目1</strong> <a href="https://www.luogu.com.cn/problem/P1143">P1143 进制转换</a></p><ul><li>题目描述：给出一个进制为 $n$ 的数 $x$，要求将其转化为进制为 $m$ 的数。</li><li>解题思路：先将 $x$ 转化为十进制数, 再将该十进制数转化为 $m$ 进制数。</li></ul></li><li><p><strong>题目2</strong> <a href="https://www.luogu.com.cn/problem/P1017">P1017 进制转换</a></p><ul><li>题目描述：读入一个十进制数和一个负进制数的基数, 输出此负进制数</li><li>背景知识：考虑 $a \% b$, 当 $a$ 和 $b$ 不一定为正数时, 其结果正负号与 $a$ 的符号保持一致。且取余结果试图使得其结果的绝对值尽可能的小。如果我们总是想要得到正数的结果, 那么当结果为负时, 我们为结果加 $abs(b)$ 即可。设所求<strong>正余数</strong>为 $a_0$, 其满足$a = b * k + a_0$。</li><li>解题思路：考虑十进制转换为 m 进制： $x_{10} = a_0 + a_1m^1 + a_2m^2 + … + a_km^k$, 其中 $m$ 都为正数, 那么对于负进制转换, 只需考虑到其中的 $m$ 都为负数即可, 此时就会遇到<strong>负数求模</strong>的情况。由于 $a_0, a_1, …, a_k$ 需要全部为正数, 因此我们只需利用上边的背景知识求解即可。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(a)&#123;    &#x2F;&#x2F; 考虑求余结果的正负性    if(a&lt;0 &amp;&amp; a%b) c &#x3D; a%b + abs(b);    else c &#x3D; a%b;    a &#x3D; (a-c)&#x2F;b;    s.push(c);&#125;while(!s.empty()) &#123;cout&lt;&lt;s.top();s.pop();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目3</strong> <a href="https://www.luogu.com.cn/problem/P1469">P1469 找筷子</a></p><ul><li>题目描述：给出若干数, 除其中的某一个数外, 其他的数都两两出现, 试找出唯一不重的那个数。</li><li><p>解题思路：异或所有的数, 最后得到的数即为唯一不重的数。我们可以将所有重复的数字两两配对并放在最前边, 将他们进行异或, 最后可以得到 0, 再拿 0  与唯一不重复的那个数 $x$ 进行异或, 最后得到 $x$ 本身。原理如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 异或运算满足交换律和结合律&#x2F;&#x2F; 且x ^ x &#x3D; 0 0 ^ x &#x3D; x&#x2F;&#x2F; 所以a ^ b ^ c ^ d ^ c ^ a ^ b &#x3D; (a ^ a) ^ (b ^ b) ^ (c ^ c) ^ d&#x3D;0 ^ 0 ^ 0 ^ d &#x3D; d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; read()为自定义的快读函数for(int i &#x3D; 0; i &lt; n; ++i)    a ^&#x3D; (b&#x3D;read());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目4</strong> <a href="https://www.luogu.com.cn/problem/P1100">P1100 高低位交换</a></p><ul><li>题目描述：给定一个小于 $2^{32}$ 的正整数, 其在计算机中通过 32 位二进制数的形式存储, 交换其前 16 位二进制数和其后的 16 位二进制数, 得到一个新的正整数, 试求出该正整数。</li><li>题目思路：我们只需要得到其前 16 位和后 16 位, 然后将其交换位置并合在一起即可。思路有很多, 给出一种体位运算特性较多的思路。假设原数字为 x 我们可以通过 <code>x &amp; 0xffff0000</code> 来得到前 16 位数字, 通过 <code>x &amp; 0x0000ffff</code> 来得到后 16 位数字, 通过移位运算调整两者的位置, 最后将两者相“<strong>或</strong>”, 从而得到答案</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 注意无符号整数才包含 2^32 内的正整数unsigned int x;cin&gt;&gt;x;&#x2F;&#x2F; 两个移位运算分别是将前 16 位二进制数放在后 16 位的位置上&#x2F;&#x2F; 和将后 16 位二进制数放在前 16 位上cout&lt;&lt;(((x &amp; 0xffff0000) &gt;&gt; 16) | ((x &amp; 0x0000ffff) &lt;&lt; 16)))&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计数原理与排列组合"><a href="#计数原理与排列组合" class="headerlink" title="计数原理与排列组合"></a>计数原理与排列组合</h2></li></ul></li><li><p><strong>题目1</strong> <a href="https://www.luogu.com.cn/problem/P1866">P1866 编号</a></p><ul><li>题目描述：给定 $n$ 个位置, 在每个位置中放置一个数字, 每个位置 $i$ 所允许的数字范围为 $1 \rightarrow maxNumber[i]$, 且每个位置所放数字不能相同, 试确定有几种放置情况。</li><li>题目思路：首先读取数组 $maxNumber[i]$, 随后将 $maxNumber[i]$ 从小到大进行排序, 随后依次分配数字即可。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i &lt; n; ++i) cin&gt;&gt;a[i];&#x2F;&#x2F; 对数组进行排序, 排序之后位置 i 之前分配的数字必然被包含在 a[i] 中sort(a, a+n);&#x2F;&#x2F; 使用 b 来存储当前已经有多少个数字被分配过了long long ans &#x3D; 1, b &#x3D; 0;for(int i &#x3D; 0; i &lt; n; ++i)&#123;    &#x2F;&#x2F; a[i] - b 表示当前位置所能摆放的数字个数    if(a[i] - b &lt;&#x3D; 0)&#123;        ans &#x3D; 0;        break;    &#125;else&#123;        ans *&#x3D; (a[i] - b);        ans %&#x3D; MOD;        ++b;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目2</strong> <a href="https://www.luogu.com.cn/problem/P2822">P2822 组合数问题</a></p><ul><li>题目描述：给出 $n$、$m$, 试求有多少对 $(i, j)$ 满足 $\{(i, j) | 0 \leq i \leq n, 0 \leq j \leq min(i, m), k | C_i^j\}$。<code>a | b</code> 表示 $b mod a == 0$。题目有多组数据, 每一组数据都会提供一个新的 $n, m$, 但是 $k$ 保持不变。</li><li><p>背景知识：杨辉三角打表。朴素的组合数求法是利用公式 $C_i^j = \frac{i!}{j!(i-j)!}$, 但是当我们需要用到大量的组合数时, 我们一一求解是不显示的, 因此需要对组合数提前进行打表。组合数有一个<strong>臭蛋公式</strong>：$C_i^j = C_{i-1}^j + C_{i-1}^{j-1}$, 使用该公式进行递推打表, 可以得到杨辉三角, 也即组合数表。代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; a[i][j] 表示 i 个物体中挑选 j 个物体的组合数void init(void)&#123;    for(int i &#x3D; 1; i &lt; maxn; ++i)&#123;        for(int j &#x3D; 0; j &lt;&#x3D; i; ++j)&#123;            if(j&#x3D;&#x3D;0 || j&#x3D;&#x3D;i) a[i][j] &#x3D; 1;            else a[i][j] &#x3D; a[i-1][j-1] + a[i-1][j];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>题目思路：使用<strong>打表 + 前缀和</strong>的方法。首先对杨辉三角进行打表, 随后由于 $k$ 值固定, 我们预先对所有的 $(i, j)$ 是否满足题目条件进行判定, 并使用数组 $b[maxn][maxn]$ 存储判定结果, $b[p][q]$ 表示所有满足 $i \leq p, j \leq q, k | C_i^j$ 的 $(i, j)$ 对儿的个数。那么对于每次查询可以使用 $O(1)$ 的时间复杂度解决问题。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void init(int k)&#123;    &#x2F;&#x2F; 模拟杨辉三角打表    for(int i &#x3D; 1; i &lt; maxn; ++i)&#123;        for(int j &#x3D; 0; j &lt;&#x3D; i; ++j)&#123;            if(j&#x3D;&#x3D;0 || j&#x3D;&#x3D;i) a[i][j] &#x3D; 1;            else a[i][j] &#x3D; a[i-1][j-1] + a[i-1][j];            &#x2F;&#x2F; 存储 a[i][j] 对 k 求余的结果            a[i][j] %&#x3D; k;        &#125;    &#125;    &#x2F;&#x2F; 得到前缀和数组    for(int i &#x3D; 1; i &lt; maxn; ++i)&#123;        for(int j &#x3D; 1; j &lt;&#x3D; i; ++j)&#123;            &#x2F;&#x2F; 三角形的前缀和递推公式            ans[i][j] &#x3D; ans[i][j-1] + ans[i-1][j] - ans[i-1][j-1];            if(!a[i][j]) ++ans[i][j];        &#125;        &#x2F;&#x2F; 由于边界条件的存在, 这条语句一定要有        ans[i][i+1] &#x3D; ans[i][i];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目3</strong> <a href="https://www.luogu.com.cn/problem/P2789">P2789 直线交点数</a></p><ul><li>题目描述：平面上有N条直线，且无三线共点，那么这些直线能有多少<strong>种</strong>不同的交点数？</li><li>题目思路：求出所有的相交情况, 求出每种相交情况的交点个数, 由于不同的相交情况可能有相同的交点数, 因此需要对交点数进行标记, 防止重复统计, 最后统计被标记的交点个数。使用动态规划思想考虑相交情况, 假设目前有 $n$ 条线, 该 $n$ 条线中有 $i$ 条直线平行, 而其余的直线与该 $i$ 条直线相交, 令 $dp[n]$ 表示 $n$ 条直线的情况, 则有 $dp[n] = \sum_{i=1}^{n}(i*(n-i)+dp[n-i])$</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 第一个参数表示有 n 条直线的状态&#x2F;&#x2F; 第二个参数表示此时的交点数目void dp(int n, int m)&#123;    if(!p &amp;&amp; !vis[m]) ++ans, vis[m] &#x3D; 1;    &#x2F;&#x2F; 对交点数进行标记    else&#123;        &#x2F;&#x2F; 枚举平行线的数量        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;            dp(n-i, m + i*(n-i));        &#125;    &#125;&#125;cout&lt;&lt;ans&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目四</strong> <a href="https://www.luogu.com.cn/problem/P3913">P3913 车的攻击</a></p><ul><li>题目描述：$N\times N$ 的国际象棋棋盘上有 $K$ 个车, 给出 $K$ 个车的位置, 求至少被一个车攻击的格子数目。(车可以攻击同一行或同一列的格子)</li><li>题目思路：将棋盘上的车投影到第一行和第一列中, 假设投影之后第一行有 $a$ 个车, 第一列有 $b$ 个车, 被攻击的格子数有 $a\times N + b\times N - a\times b$。说起投影, 第一反应是使用一个 $vis$ 数组, 但是本体 $N$ 的数据范围为 1e9, 因此会 MLE。我采用的是哈希表解决该问题, 使用 STL 中的 sort 和 unique()(去重函数) 也可以解决该问题</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 采用哈希表的方式进行投影&#x2F;&#x2F; num 表示在第一行(列)上车的投影个数&#x2F;&#x2F; 一列(行)中可能有多个车, 投影的目的就是排除这些重复的车void insert(int n, int *a, long long &amp;num)&#123;    int i &#x3D; n%maxn;    if(!a[i]) a[i] &#x3D; n, ++num;    else&#123;        while(a[i] !&#x3D; n &amp;&amp; a[i]) i &#x3D; (i+1)%maxn;        if(!a[i]) a[i] &#x3D; n, ++num;    &#125;&#125;int main()&#123;    int n, k, a, b;    long long p &#x3D; 0, q &#x3D; 0;    n&#x3D;read(); k&#x3D;read();    for(int i &#x3D; 0; i &lt; k; ++i)&#123;        a &#x3D; read(); b &#x3D; read();        &#x2F;&#x2F; 分别向第一行插入位置信息, 向第一列插入位置信息        insert(a, row, p); insert(b, col, q);    &#125;    cout&lt;&lt;p*n+q*n-p*q&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目5</strong> <a href="https://www.luogu.com.cn/problem/P2638">P2638 安全系统</a></p><ul><li>题目描述：有 $n$ 个连续存储区, 每一个存储区可以存储任意个数的 0 或 1, 现给出 $a$ 个 0, 以及 $b$ 个 1, 将其存储在存储区中(无需使用全部的 0 和 1), 问有多少种存储方式。</li><li>题目思路：我们可以发现存储 0 和存储 1 之间并不相关。因此我们只需分别枚举存储 0 的情况和存储 1 的情况, 然后将其相乘即可。首先考虑如何存储 0, 将 $i$ 个 0 平均分到 $n$ 个区域中, 且允许区域为空, 我们可以使用升级版的<strong>插板法</strong>, 可以求得有 $C_{a+n-1}^{n-1}$ 种情况。分配 1 的情况同理。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">generate(max(a+n, b+n));    &#x2F;&#x2F; 对组合数进行打表for(int i &#x3D; 0; i &lt;&#x3D; a; ++i)&#123;&#x2F;&#x2F; 枚举放入多少个 0    for(int j &#x3D; 0; j &lt;&#x3D; b; ++j)&#123;    &#x2F;&#x2F; 枚举放入多少个 1        ans +&#x3D; 1ull* c[i-1+n][n-1] * c[j-1+n][n-1]; &#x2F;&#x2F; 将两者的情况数相乘    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>题目6</strong> <a href="https://www.luogu.com.cn/problem/P1246">1246 编码</a></p><ul><li>题目描述：有 26 个字母, 将其组合成特殊的单词, 这些单词中的字母按照严格升序的顺序进行严格排序, 得到$a,b,…,z,ab,ac,…,az,…,yz,…abc,…$ 的一系列单词, 将这些单词按照其在序列中的顺序从 1 开始进行编号。现给定一个特殊单词, 求出它的编号。</li><li>解题思路：这道题是使用一个巧妙的组合思想来求解的。假设给定单词为 $dgz$, 我们只需求出其前边有几个单词再加 1 即可。该单词有 3 位, 我们先找出 2 位的单词和 1 位的单词有多少个, 对于 2 位的单词, 我们知道其不会有重复的, 并且其固定按照升序排序, 因此可以转换成在 26 个字母中挑出 2 个字母的问题, 其值为 $C_{26}^2$, 1 位数的单词同理, 接下来我们只需考虑在其之前三位数的单词的个数即可。我们可以接着考虑以 $a、b、c$ 开头的三位数单词的个数, 随后考虑以 $de、df$ 开头的单词的个数, 依次类推。最后将所有单词加起来再加一就是目标单词的编号。</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 用于得到组合数, 此处非打表LL c(LL n, LL m)&#123;    if(!m) return 1;    LL num &#x3D; 1;    for(LL i &#x3D; n; i &gt; n-m; --i)&#123;        num *&#x3D; i;    &#125;    for(LL i &#x3D; m; i &gt; 0; --i)&#123;        num &#x2F;&#x3D; i;    &#125;    return num;&#125;&#x2F;&#x2F; 用于得到所有位数小于目标单词的单词的数目for(int i &#x3D; 1; i &lt; len; ++i)&#123;    ans +&#x3D; c(letter, i);&#125;&#x2F;&#x2F; 用于得到位数与目标单词位数相同, 且位置在其之前的单词的个数int last &#x3D; 0;for(int i &#x3D; 0; i &lt; len; ++i)&#123;    for(int j &#x3D; last+1; j &lt;&#x3D; str[i]-&#39;a&#39;; ++j)&#123;        ans +&#x3D; c(letter-j, len-i-1);    &#125;    last &#x3D; str[i]-&#39;a&#39;+1;&#125;cout&lt;&lt;ans+1&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整除理论"><a href="#整除理论" class="headerlink" title="整除理论"></a>整除理论</h2></li></ul></li><li><p><strong>题目1</strong> <a href="https://www.luogu.com.cn/problem/P3383">P3383 线性筛素数</a></p><ul><li>题目描述：给出 $q$ 个查询, 每次要求输出第 $k_i$ 小的素数</li><li>解题思路：欧拉筛、埃氏筛都可以使用</li><li><p>主要代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 埃氏筛思想：从小到大逐个得到小于 n 的质数&#x2F;&#x2F; 每得到一个质数，就将 n 以内该质数的所有倍数筛去int Eratosthenes(int n, int *pri)&#123;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i])&#123;    &#x2F;&#x2F; 满足该条件说明 i 为质数            pri[cnt++] &#x3D; i;            &#x2F;&#x2F; 筛去所有质数的倍数            &#x2F;&#x2F; 对于 k * i，当 k &lt; i 时该数已经被 k 筛去            &#x2F;&#x2F; 故 k 从 i 开始            for(long long j &#x3D; i * i * 1ll; j &lt;&#x3D; n; j +&#x3D; i)                vis[j] &#x3D; 1;        &#125;&#125;&#x2F;&#x2F; 欧拉筛思想：枚举从 1 到 n 的所有数 i&#x2F;&#x2F; 使 i 乘上所有已求得的质数筛去合数&#x2F;&#x2F; 通过最小因子的思想进行线性优化，即每一个数都被其最小因子筛掉，而不是被其他因子筛掉int Euler(int n, int *pri)&#123;    for(int i &#x3D;2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i]) pri[cnt++] &#x3D; i; &#x2F;&#x2F; 满足该条件说明 i 为质数        for(int j &#x3D; 0; j &lt; cnt; ++j)&#123;            if(1ll * pri[j] * i &gt; n) break;            vis[i * pri[j]] &#x3D; 1;            &#x2F;&#x2F; 下面的代码是优化的核心            &#x2F;&#x2F; 对于 i * pri[j]，若 i % pri[j] &#x3D;&#x3D; 0            &#x2F;&#x2F; 则 i &#x3D; pri[j] * n&#39;            &#x2F;&#x2F; 那么对于 i * pri[k]，k &gt; j            &#x2F;&#x2F; i * pri[k] &#x3D; pri[j] * n&#39; * pri[k] &#x3D; pri[j] * (n&#39; * pri[k])            &#x2F;&#x2F; 其中 pri[j] 是 i * pri[k] 的最小因子            &#x2F;&#x2F; 数 i * pri[k] 在之后会通过 pri[j] * (n&#39; * pri[k]) 筛掉，无需在此处筛去            if(i % pri[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="2020/12/18/ou-la-han-shu/"/>
      <url>2020/12/18/ou-la-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>[TOC]</p><blockquote><p>本来好好的刷着排列组合的题目鬼知道怎么蹦出来了一个欧拉函数的题，以前也没有接触过，那就只能学一学喽</p></blockquote><p><strong>整理自<a href="https://oi-wiki.org/math/euler/">oi-wiki-欧拉函数</a></strong></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>当需要求取多个数的欧拉函数时，需要借助<strong>埃氏筛</strong>和<strong>欧拉筛</strong>的相关思想。</p><h3 id="埃氏筛-Eratosthenes"><a href="#埃氏筛-Eratosthenes" class="headerlink" title="埃氏筛(Eratosthenes)"></a>埃氏筛(Eratosthenes)</h3><p>时间复杂度为 $O(nlglgn)$，<del>我不会证QAQ</del></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 埃氏筛思想：从小到大逐个得到小于 n 的质数&#x2F;&#x2F; 每得到一个质数，就将 n 以内该质数的所有倍数筛去int Eratosthenes(int n, int *pri)&#123;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i])&#123;    &#x2F;&#x2F; 满足该条件说明 i 为质数            pri[cnt++] &#x3D; i;            &#x2F;&#x2F; 筛去所有质数的倍数            &#x2F;&#x2F; 对于 k * i，当 k &lt; i 时该数已经被 k 筛去            &#x2F;&#x2F; 故 k 从 i 开始            for(long long j &#x3D; i * i * 1ll; j &lt;&#x3D; n; j +&#x3D; i)                vis[j] &#x3D; 1;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><p>时间复杂度为 $O(n)$，每一个数仅被访问一次</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 欧拉筛思想：枚举从 1 到 n 的所有数 i&#x2F;&#x2F; 使 i 乘上所有已求得的质数筛去合数&#x2F;&#x2F; 通过最小因子的思想进行线性优化，即每一个数都被其最小因子筛掉，而不是被其他因子筛掉int Euler(int n, int *pri)&#123;    for(int i &#x3D;2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i]) pri[cnt++] &#x3D; i; &#x2F;&#x2F; 满足该条件说明 i 为质数        for(int j &#x3D; 0; j &lt; cnt; ++j)&#123;            if(1ll * pri[j] * i &gt; n) break;            vis[i * pri[j]] &#x3D; 1;            &#x2F;&#x2F; 下面的代码是优化的核心            &#x2F;&#x2F; 对于 i * pri[j]，若 i % pri[j] &#x3D;&#x3D; 0            &#x2F;&#x2F; 则 i &#x3D; pri[j] * n&#39;            &#x2F;&#x2F; 那么对于 i * pri[k]，k &gt; j            &#x2F;&#x2F; i * pri[k] &#x3D; pri[j] * n&#39; * pri[k] &#x3D; pri[j] * (n&#39; * pri[k])            &#x2F;&#x2F; 其中 pri[j] 是 i * pri[k] 的最小因子            &#x2F;&#x2F; 数 i * pri[k] 在之后会通过 pri[j] * (n&#39; * pri[k]) 筛掉，无需在此处筛去            if(i % pri[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="欧拉函数-Euler’s-totient-function-的定义"><a href="#欧拉函数-Euler’s-totient-function-的定义" class="headerlink" title="欧拉函数(Euler’s totient function)的定义"></a>欧拉函数(Euler’s totient function)的定义</h2><p>使用 $\phi(x)$ 来代表欧拉函数，其表示的是小于等于 $x$ 和 $x$ 互质的数的个数。根据定义我们可以知道 $\phi(1) = 1$，当 $p$ 为质数时 $\phi(p) = p-1$。注意，1 与任何数都互质。</p><h2 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h2><ul><li>欧拉函数是积性函数<br>  欧拉函数为积性函数是指当 $a$, $b$ 两个数互质时，即 $gcd(a, b) = 1$，$\phi(a \times b)= \phi(a) \times \phi(b)$<br>  特别的，当 $n$ 为奇数时，$\phi(2n) = \phi(n)$</li><li>$n = \sum_{d|n}\phi(d)$<br>  上述公式可以解释为所有 $n$ 的因数的欧拉函数的和为 $n$ 本身。可以使用<a href="https://oi-wiki.org/math/mobius/">莫比乌斯反演</a>来证明，然而我不会。此处使用其他方法证明。<br>  <strong>条件一</strong>：如果 $gcd(k, n) = d$，即 $k$ 与 $n$ 的最大公因数为 $d$，那么当 $k$ 与 $n$ 同时除以 $d$ 时（$k$ 和 $n$ 一定可以整除 $d$），$\frac{k}{d}$ 与 $\frac{n}{d}$ 互质。有 $gcd(\frac{k}{d},\frac{n}{d}) = 1$<br>  <strong>条件二</strong>：如果令 $f(x)$ 表示满足 $gcd(k, n) = x$ 的 $k$ 的个数，即 $f(x)$ 为所有小于等于 $n$ 的数中和 $n$ 的最大公倍数为 $x$ 的数的个数，那么有<script type="math/tex">n = f(1) + f(2) + f(3) + ... + f(n) = \sum_{i=1}^{n}f(i)</script>其原因在于，对于任意从 1 到 $n$ 之间的数字 $m$，$m$ 只可能与 $n$ 有唯一的一个最大公因数 $i$，且 $i \leq n$，那么我们只需枚举从 1 到 $n$ 中所有的数字 $i$ 作为最大公因数，并累加 $f(i)$，其就代表枚举了 $m$ 从 1 到 $n$ 的所有情况，故 $\sum_{i=1}^n f(x) = n$<br>  &emsp;<br>  根据上述两个条件，我们可以找到 $f(x)$ 定义的等价形式，即$f(x)$ 表示满足 $gcd(\frac{k}{x}, \frac{n}{x}) = 1$ 的 $k$ 的个数，把 $\frac{k}{x}$ 看做 $k$，则 $f(x)$ 表示满足 $gcd(k, \frac{n}{x}) = 1$ 的 $k$ 的个数，根据欧拉函数的定义，可以发现 $f(x) = \phi(\frac{n}{x})$。<br>  这时有 $n = \sum_{i=1}^{n}f(i) = \sum_{i=1}^{n}\phi(\frac{n}{i}) =\sum_{d|n}\phi(d))$。</li><li>若 $n = p^k$，且 $p$ 为质数，那么 $\phi(n) = p^k-p^{k-1}$。原因是从 1 到 $n$ 中所有与 $n$ 不互质的数的个数有 $n/p = n^p/p = p^{k-1}$ 个，故与 $n$ 互质的数的个数有 $n-p^{k-1}=p^k-p^{k-1}$ 个。</li><li>由唯一分解定理，设 $n=\prod_{i=1}^n{p_i^{k_i}}$，由于 $\phi(n)$ 为积性函数，故</li></ul><script type="math/tex; mode=display">\begin{aligned}phi(n) =& \prod_{i=1}^n\phi(p_i^{k_i})\\=& \prod_{i=1}^n(p^k-p^{k-1})\\=& \prod_{i=1}^np_i^k(1-\frac{1}{p_i})\\=& \prod_{i=1}^np_i^k\times\prod_{i=1}^n(1-\frac{1}{p_i})\\=& n\times\prod_{i=1}^n(1-\frac{1}{p_i})\end{aligned}</script><p>我们可以得到欧拉函数的对应公式：</p><script type="math/tex; mode=display">\phi(n) = n \times \prod_{i=1}^n(1-\frac{1}{p_i})</script><h2 id="求出单个欧拉函数的值"><a href="#求出单个欧拉函数的值" class="headerlink" title="求出单个欧拉函数的值"></a>求出单个欧拉函数的值</h2><p>我们可以简单的根据上述欧拉公式来求得单个欧拉函数的值：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int euler_phi(int x)&#123;    int ans &#x3D; n;    for(int i &#x3D; 2; i * i &lt;&#x3D; n; ++i)&#123;        if(n % i &#x3D;&#x3D; 0)&#123;            ans &#x3D; ans &#x2F; i * (i - 1);            whiel(n % i &#x3D;&#x3D; 0) n &#x2F;&#x3D; i;        &#125;    &#125;    &#x2F;&#x2F; 特判 n 为质数的情况    if(n &gt; 1) ans &#x3D; ans &#x2F; n * (n-1);    return n;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法可以使用 <a href="https://oi-wiki.org/math/pollard-rho/">Pollard Rho</a>进行优化，然而菜鸡的我现在貌似还用不到。</p><h2 id="求出多个欧拉函数的值"><a href="#求出多个欧拉函数的值" class="headerlink" title="求出多个欧拉函数的值"></a>求出多个欧拉函数的值</h2><p>借助上述的公式，我们可以借用埃氏筛的思想求欧拉函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void phi_table(int n, int *phi)&#123;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i) phi[i] &#x3D; 0;    phi[1] &#x3D; 1;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)        if(!phi[i])&#123;            for(int j &#x3D; i; j &lt;&#x3D; n; j +&#x3D; i)&#123;                if(!phi[j]) phi[j] &#x3D; j;                phi[j] &#x3D; phi[j] &#x2F; i * (i - 1);            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过欧拉筛来线性求解多个欧拉函数的值。首先需要进行公式推导:</p><p>在欧拉筛的过程中，每一个合数都是被其最小因数筛掉的，我们设该最小因数为 $p_1$，剩余部分为 $n’$，两者满足关系 $p_1*n’=n$。<br>考虑 $n’$ 的两种情况，如果 $n’ \bmod p_1 = 0$，则 $n’$ 包含了 $n$ 的全部质因子。</p><script type="math/tex; mode=display">\begin{aligned}\phi(n) =& n \times \prod_{i=1}^n{\frac{p_i-1}{p_i}}\\=&p_1\times n' \times \prod_{i=1}^n{\frac{p_i-1}{p_i}}\\=&p_1\times \phi(n')\end{aligned}</script><p>如果 $n’ \bmod p_1 \neq 0$，则 $p_1$ 和 $n’$ 互质，根据欧拉函数的性质有</p><script type="math/tex; mode=display">\begin{aligned}\phi(n) =& \phi(n') \times \phi(p_1)\\=& \phi(n') \times (p_1 - 1)\end{aligned}</script><p>据此，我们可以在通过欧拉筛得到质数的同时得到欧拉函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int euler(int n, int* phi, int* pri)&#123;    phi[1] &#x3D; 1;    for(int i &#x3D; 2; i &lt;&#x3D; n; ++i)&#123;        if(!vis[i])&#123;            &#x2F;&#x2F; 对于质数直接进行标记            phi[i] &#x3D; i - 1;            pri[cnt++] &#x3D; i;            vis[i] &#x3D; 1;        &#125;        for(int j &#x3D; 0; j &lt; cnt; ++j)&#123;            if(1ll * pri[j] * i &gt; n) break;            vis[i * pri[j]] &#x3D; 1;            if(i % pri[j])&#123;                &#x2F;&#x2F; 对应第二种情况                phi[i * pri[j]] &#x3D; phi[i] * (pri[j] - 1);            &#125;else&#123;                &#x2F;&#x2F; 对应第一种情况                phi[i * pri[j]] &#x3D; phi[i] * pri[j];                break;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/18/hello-world/"/>
      <url>2020/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
